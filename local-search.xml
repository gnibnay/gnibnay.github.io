<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（五）</title>
    <link href="/2025/01/10/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_5/"/>
    <url>/2025/01/10/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_5/</url>
    
    <content type="html"><![CDATA[<h2 id="宏的陷阱">宏的陷阱</h2><p>  在本节中，将介绍一些适用于宏和宏扩展的特殊规则，并指出在某些情况下，这些规则会产生与直觉相反的后果，<strong>必须加以注意</strong>。</p><h3 id="嵌套错误-⌊Misnesting⌉">嵌套错误 ⌊Misnesting⌉</h3><p>  当一个宏被调用时，它的参数会被代入宏体中，<strong>并且代入后的结果会和输入文件的其他部分一起被检查，以查找更多的宏调用</strong>。有可能将一个宏调用的一部分来自宏体本身，另一部分来自参数拼接在一起。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> twice(x) (2*(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> call_with_1(x) x(1)</span><br><br><span class="hljs-built_in">call_with_1</span>(twice)<br></code></pre></td></tr></table></figure><p>  这个例子中，<code>call_with_1(twice)</code> 首先会被展开为 <code>twice(1)</code>，然后预处理器会再次检查部分展开后的结果。然后 <code>twice(1)</code> 会被展开为 <code>(2*(1))</code>，得到最终的展开结果。</p><p>$$\begin{aligned} call_with_1(twice) \rightarrow twice(1) \\ \rightarrow (2*(1)) \end{aligned}$$</p><p>  宏定义<strong>不必带有平衡的圆括号</strong>。通过在宏体中编写一个不平衡的开括号，可以创建一个宏调用，它从宏体内部开始，但在宏体之外结束。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> strange(file) fprintf (file, <span class="hljs-string">&quot;%s %d&quot;</span>,</span><br><br><span class="hljs-built_in">strange</span>(stderr) p, <span class="hljs-number">35</span>)<br></code></pre></td></tr></table></figure><p>  这个例子最终的展开结果是 <code>fprintf (stderr, &quot;%s %d&quot;, p, 35)</code>。这里调用了<code>strange</code>宏，并传入<code>stderr</code>作为参数。由于宏体中的括号不平衡，宏展开时，<code>strange(stderr)</code>展开为<code>fprintf (stderr, &quot;%s %d&quot;,</code>，此时<strong>宏展开还没有结束</strong>，因为左括号没有完全匹配。所以，后面的<code>p, 35)</code>会被视为宏调用的一部分，继续展开。</p><blockquote><p>这种使用方式虽然在技术上是可行的，但非常不推荐，因为它会使代码难以理解和维护。括号不平衡的宏定义很容易导致错误，尤其是在复杂的宏定义和调用场景中，可能会引发编译错误或其他难以调试的问题。因此，通常建议在宏定义中保持括号的平衡，以避免这类潜在的陷阱。</p></blockquote><h3 id="运算符优先级问题-⌊Operator-Precedence-Problems⌉">运算符优先级问题 ⌊Operator Precedence Problems⌉</h3><p>  你可能也注意到了，在大多数宏定义示例中，<strong>宏参数名周围有括号</strong>，并且<strong>整个宏定义通常也被一对括号包围</strong>。这么做的原因实际上是<strong>为了避免运算符优先级问题和其他潜在的陷阱</strong>。</p><h4 id="为什么宏参数名周围需要有括号">为什么宏参数名周围需要有括号</h4><p>  在宏定义中，每个参数周围加上括号可以确保参数在宏展开时被正确地视为一个整体，避免由于运算符优先级问题导致的错误。例如下面这个宏定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MULTI(x, y) (x) * (y)</span><br></code></pre></td></tr></table></figure><p>如果宏定义中没有括号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MULTI(x, y) x * y</span><br></code></pre></td></tr></table></figure><p>那么在使用宏时，如果传入的参数是复杂的表达式，就会出现问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> result = <span class="hljs-built_in">MULTI</span>(<span class="hljs-number">3</span> + <span class="hljs-number">4</span>, <span class="hljs-number">5</span> + <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>宏展开后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> result = <span class="hljs-number">3</span> + <span class="hljs-number">4</span> * <span class="hljs-number">5</span> + <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>但是，根据运算符优先级，<code>*</code> 的优先级高于 <code>+</code>。于是实际上表达式会被计算为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> result = <span class="hljs-number">3</span> + (<span class="hljs-number">4</span> * <span class="hljs-number">5</span>) + <span class="hljs-number">6</span>; <span class="hljs-comment">// = 29</span><br></code></pre></td></tr></table></figure><p>而不是我们期望的结果：<code>(3 + 4) * (5 + 6) = 77</code></p><h4 id="为什么宏定义周围需要有括号">为什么宏定义周围需要有括号</h4><p>  同样是出于避免由于运算符优先级问题导致的错误，而需要使用括号确保宏展开后的整个表达式正确地被视为一个整体。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD(x, y) ((x) + (y))</span><br></code></pre></td></tr></table></figure><p>如果这个宏定义没有括号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD(x, y) (x) + (y)</span><br></code></pre></td></tr></table></figure><p>而在调用是传入复杂的表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> result = <span class="hljs-number">2</span> * <span class="hljs-built_in">ADD</span>(<span class="hljs-number">3</span> + <span class="hljs-number">4</span>, <span class="hljs-number">5</span> + <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>展开后的结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> result = <span class="hljs-number">2</span> * (<span class="hljs-number">3</span> + <span class="hljs-number">4</span>) + (<span class="hljs-number">5</span> + <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>显然，这与我们的预期结果不符。</p><h4 id="总结">总结</h4><p>  在宏定义中，每个宏参数名周围加上括号，以及整个宏定义周围加上括号，可以确保宏展开后的表达式按照预期的方式进行计算，避免因运算符优先级问题导致的错误。这样可以提高代码的可读性和可维护性，减少潜在的<code>bug</code>。</p><h3 id="吞掉分号-⌊Swallowing-the-Semicolon⌉">吞掉分号 ⌊Swallowing the Semicolon⌉</h3><p>  通常，定义一个拓展为<strong>复合语句</strong>的宏是需要的。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SKIP_SPACES(p, limit)  \</span><br><span class="hljs-meta">&#123; char *lim = (limit);         \</span><br><span class="hljs-meta">  while (p &lt; lim) &#123;            \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (*p++ != <span class="hljs-string">&#x27; &#x27;</span>) &#123;         \</span><br><span class="hljs-meta">      p--; break; &#125;&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>  这个例子中定义的宏可以将一个指针 <code>p</code> 跳过空白字符。这里使用了 <code>\</code> 来分割宏定义，因为宏定义必须是单逻辑行。而 <code>C/C++</code> 本身以<code>;</code> 表示语句的结束而不是换行，所以宏定义的单逻辑行是可以容纳复合语句的。</p><p>  对此宏的一个调用可以是 <code>SKIP_SPACES(p, lim)</code>。严格上讲，此宏将被拓展为一个复合语句，而它是一个完整的语句，所以不需要分号 <code>;</code> 来结束。但是，由于此宏调用看起来像函数调用，如果可以像函数调用一样来使用这个宏——在其末尾写一个分号（相当于后接了一条空语句），如 <code>SKIP_SPACES(p, limit);</code>，可以最大程度上减少混淆。</p><p>  这对 <code>if-else</code> 语句就带来了麻烦。因为分号 <code>;</code> 本身可以被视为一个空语句。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (*p != <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">SKIP_SPACES</span>(p, lim);<br><span class="hljs-keyword">else</span> ...<br></code></pre></td></tr></table></figure><p>  这就使得这段代码实际上变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (*p != <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">SKIP_SPACES</span>(p, lim)<br>    ;   <span class="hljs-comment">// 空语句</span><br><span class="hljs-keyword">else</span> ...<br></code></pre></td></tr></table></figure><p>显然，这段代码是无效的，除非在在调用时人为加个 <code>&#123;&#125;</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (*p != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">SKIP_SPACES</span>(p, lim)<br>    ;   <span class="hljs-comment">// 空语句</span><br>&#125;<br><span class="hljs-keyword">else</span> ...<br></code></pre></td></tr></table></figure><p>这确实是一个方法，实际上仍然可以选择修改 <code>SKIP_SPACES</code> 本身的宏定义，使用 <code>do-while</code> 语句来解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SKIP_SPACES(p, limit)     \</span><br><span class="hljs-meta">do &#123; char *lim = (limit);         \</span><br><span class="hljs-meta">     while (p &lt; lim) &#123;            \</span><br><span class="hljs-meta">       <span class="hljs-keyword">if</span> (*p++ != <span class="hljs-string">&#x27; &#x27;</span>) &#123;         \</span><br><span class="hljs-meta">         p--; break; &#125;&#125;&#125;          \</span><br><span class="hljs-meta">while (0)</span><br></code></pre></td></tr></table></figure><blockquote><p><code>C/C++</code> 中的 <code>do-while</code> 语句本身末尾需要分号 <code>;</code> 表示结束。所以，以函数调用的形式，正好对宏体中的 <code>do-while</code> 语句补齐了最后的分号 <code>;</code>。</p></blockquote><p>现在，这样的调用 <code>SKIP_SPACES(p, lim);</code> 会被展开为 <code>do &#123;...&#125; while (0);</code> ，而循环只会执行一次。</p><h3 id="副作用的重复-⌊Duplication-of-Side-Effects⌉">副作用的重复 ⌊Duplication of Side Effects⌉</h3><p>  很多的 <code>C</code> 程序会定义一个宏 <code>min</code>，用来求取最小值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span><br></code></pre></td></tr></table></figure><p>当用带有副作用的参数去调用这个宏时，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">next = <span class="hljs-built_in">min</span> (x + y, <span class="hljs-built_in">foo</span> (z));<br></code></pre></td></tr></table></figure><p>此宏就会被展开为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">next = ((x + y) &lt; (<span class="hljs-built_in">foo</span> (z)) ? (x + y) : (<span class="hljs-built_in">foo</span> (z)));<br></code></pre></td></tr></table></figure><p>发现问题了吗？这里的 <code>foo(z)</code> 实际上可能会被执行两次，如果 <code>foo()</code> 本身具有副作用（比如每次调用让静态变量加 <code>1</code>等等），这显然不符合调用此宏的预期。因此，可以认为此 <code>min</code> 宏不是一个安全的宏。</p><p>  解决这个问题的最佳方法是在定义 <code>min</code> 时只计算一次 <code>foo(z)</code> 的值。<code>C</code> 语言本身并没有提供标准的实现方法，但是可以通过 <code>GNU</code> 拓展实现如下功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(X, Y)                \</span><br><span class="hljs-meta">(&#123; typeof (X) x_ = (X);          \</span><br><span class="hljs-meta">   typeof (Y) y_ = (Y);          \</span><br><span class="hljs-meta">   (x_ &lt; y_) ? x_ : y_; &#125;)</span><br></code></pre></td></tr></table></figure><p><code>(&#123;...&#125;)</code> 产生一个复合语句，于是可以在其内部定义局部变量，并且为每个参数分配一个局部变量。这里的问题就是，定义一个局部变量需要直到参数的类型，所以，这里使用 <code>typeof</code> 来获取参数的类型是关键。通过局部变量，就可以很有效地避免副作用的重复。</p><p>  当然，如果不想或者不能使用 <code>GUN</code> 拓展提供的 <code>typeof</code> 方法，那么使用这类的 <code>min</code> 宏就需要格外小心。如果明确知道参数的类型，就可以用具体的类型替代 <code>typeof</code> 的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(X, Y)                \</span><br><span class="hljs-meta">(&#123; int x_ = (X);          \</span><br><span class="hljs-meta">   int y_ = (Y);          \</span><br><span class="hljs-meta">   (x_ &lt; y_) ? x_ : y_; &#125;)</span><br></code></pre></td></tr></table></figure><p>这里假设参数 <code>X</code> 和 <code>Y</code> 都是 <code>int</code> 类型（或者返回 <code>int</code> 类型）。</p><h3 id="自引用宏-⌊Self-Referential-Macros⌉">自引用宏 ⌊Self-Referential Macros⌉</h3><p>  所谓<strong>自引用宏</strong>是指<u>宏名出现在其宏体中的宏</u>。前面讲过，所有的宏展开后会被重新扫描，以寻找更多可替代的宏。显然，如果可以将宏进行<strong>自我引用</strong>，就会产生无限大的扩展。为了避免这种情况，自引用不会被认为是宏调用，它会被原封不动地传入预处理器的输出中。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo (4+foo)</span><br></code></pre></td></tr></table></figure><p>  按照普遍的规则，对 <code>foo</code> 的每次调用都会拓展为 <code>(4+foo)</code>。然后重新扫描，并拓展为 <code>(4+(4+foo))</code>。以此类推，直到内存耗尽。</p><p>  而按照自引用的规则，这一过程被缩短到 <code>(4+foo)</code>。也就是说，<strong>宏体中的同名宏将不会被预处理器展开</strong>。在这个例子里，无论何处调用 <code>foo</code>，其结果都是将 <code>foo</code> 加上 <code>4</code>。</p><p>  大多数情况下，这并非一个好主意。因为阅读代码的人看到 <code>foo</code> 类的宏调用，会将其视为一个变量而不是一个宏。并理所应当地将其值认为是 <code>foo</code> 变量的值，实际上的值比其大 <code>4</code>。</p><p>  实际上，自引用宏还有一类情况：<u>不同宏定义之间交叉引用</u>。比如，宏 <code>x</code> 的宏体中使用宏 <code>y</code>，而宏 <code>y</code> 的宏体中使用 <code>x</code>，这样就造成了宏 <code>x</code> 的间接自引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> x (4 + y)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y (2 * x)</span><br></code></pre></td></tr></table></figure><p>这个例子会被展开为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">x  → (<span class="hljs-number">4</span> + y)<br>   → (<span class="hljs-number">4</span> + (<span class="hljs-number">2</span> * x))<br><br>y  → (<span class="hljs-number">2</span> * x)<br>   → (<span class="hljs-number">2</span> * (<span class="hljs-number">4</span> + y))<br></code></pre></td></tr></table></figure><p>即，每个宏在其他宏的定义中出现时都会展开，但间接出现在自身定义中时不会展开。</p><h3 id="参数预扫描-⌊Argument-Prescan⌉">参数预扫描 ⌊Argument Prescan⌉</h3><p>  在 <code>C</code> 语言预处理中，宏参数的展开机制颇为有趣且关键。通常情况下，宏参数在被替换到宏体之前，会先进行完全的宏展开，除非它们被字符串化或与其他标记拼接。替换后，整个宏体，包括替换后的参数，<strong>会被再次扫描以展开其中的宏调用</strong>。这就意味着参数会被<strong>扫描两次</strong>来展开其中的宏调用。</p><p>  大多数时候，这种双扫描机制似乎没什么影响。如果参数中包含宏调用，它们会在第一次扫描时被展开。因此，展开后的结果中不再包含宏调用，所以第二次扫描也不会改变它。如果参数没有预扫描就被直接替换，那么剩下的那次扫描也会找到相同的宏调用并产生相同的结果。</p><p>  你可能会想，当一个自引用宏被用作另一个宏的参数时（参见自引用宏），双扫描机制会不会改变结果：自引用宏会在第一次扫描时展开一次，然后在第二次扫描时再展开一次。然而，事实并非如此。<strong>在第一次扫描中没有展开的自引用会被标记，使得它们在第二次扫描时也不会展开</strong>。</p><p>  你可能会疑惑，“如果预扫描没有区别，为什么要提它呢？为什么不跳过它让预处理器更快呢？”答案是，预扫描在三种特殊情况下确实有区别：</p><ul><li><p><strong>宏的嵌套调用</strong><br>我们说嵌套宏调用发生在宏的参数中包含对该宏本身的调用时。例如，如果 <code>f</code> 是一个期望一个参数的宏，那么 <code>f(f (1))</code> 就是一对嵌套的 <code>f</code> 调用。期望的展开方式是先展开 <code>f(1)</code>，然后将展开结果代入 <code>f</code> 的定义中。预扫描使得预期的结果能够顺利出现。<strong>如果没有预扫描</strong>，<code>f(1)</code> 本身就会作为参数被代入，在主扫描过程中，内部的 <code>f</code> 调用会表现为间接的自引用，从而不会被展开。</p></li><li><p><strong>调用其他宏进行字符串化或拼接的宏</strong><br>如果宏的参数被字符串化或拼接，预扫描就不会发生。如果你想先展开一个宏，然后再对它的展开结果进行字符串化或拼接，可以通过让一个宏调用另一个进行字符串化或拼接的宏来实现。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> AFTERX(x) X_ ## x</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XAFTERX(x) AFTERX(x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE TABLESIZE</span><br></code></pre></td></tr></table></figure><p>在这种情况下，<code>AFTERX(BUFSIZE)</code> 展开为 <code>X_BUFSIZE</code>，而 <code>XAFTERX(BUFSIZE)</code> 展开为 <code>X_1024</code>（而不是 <code>X_TABLESIZE</code>，因为预扫描总是进行完整的展开）。</p></li><li><p><strong>参数中宏展开包含未保护逗号的宏</strong><br>这可能会导致在第二次扫描时展开的宏被错误地调用，传入了错误数量的参数。来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo  a,b</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bar(x) lose(x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lose(x) (1 + (x))</span><br></code></pre></td></tr></table></figure><p>我们希望 <code>bar(foo)</code> 能够变成 <code>(1 + (foo))</code>，然后再变成 <code>(1 + (a,b))</code>。然而，实际上 <code>bar(foo)</code> 展开成了 <code>lose(a,b)</code>，这时就会出现错误，因为 <code>lose</code> 需要一个单一的参数。在这种情况下，问题可以通过使用本就应该用来防止算术运算嵌套错误的括号来轻松解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo (a,b)</span><br></code></pre></td></tr></table></figure><p>或者，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> bar(x) lose((x))</span><br></code></pre></td></tr></table></figure><p>额外的一对括号可以防止 <code>foo</code> 定义中的逗号被解释为参数分隔符。</p></li></ul><h3 id="参数中的换行-⌊Newlines-in-Arguments⌉">参数中的换行 ⌊Newlines in Arguments⌉</h3><p>  类函数宏的调用可以跨越多个行。然而在当前的实现中，整个宏展开的结果都出现在这一行。这就导致编译器或者调试器发出的行号信息引用的是宏调用开始的那一行，这就可能与导致问题的参数的那一行不同。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ignore_second_arg(a,b,c) a; c</span><br><span class="hljs-built_in">ignore_second_arg</span> (<span class="hljs-built_in">foo</span> (),<br>                  <span class="hljs-built_in">ignored</span> (),<br>                  syntax error);<br></code></pre></td></tr></table></figure><p>  由标记 <code>syntax error</code> 触发的语法错误会导致错误消息引用第三行——即 <code>ignore_second_arg</code> 宏所在的行，尽管有问题的代码实际上来自第五行。</p><blockquote><p>因为时间问题，这个 <code>bug</code> 已经被修复了，可以忽略。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
      <category>Macros</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>C</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YOLO v2 论文分享</title>
    <link href="/2025/01/04/YOLO/YOLO_v2/"/>
    <url>/2025/01/04/YOLO/YOLO_v2/</url>
    
    <content type="html"><![CDATA[<h1>$YOLO9000:\ Better,\ Faster,\ Stronger$</h1><blockquote><p><a href="https://openaccess.thecvf.com/content_cvpr_2017/papers/Redmon_YOLO9000_Better_Faster_CVPR_2017_paper.pdf">论文链接</a></p></blockquote><h2 id="摘要-⌊Abstract⌉">摘要 ⌊Abstract⌉</h2><p>  这篇论文介绍了<code>YOLO9000</code>，这是一个先进的实时目标检测系统，能够检测超过<code>9000</code>个目标类别。首先，作者提出了一系列对<code>YOLO</code>检测方法的改进，形成了<code>YOLOv2</code>模型。<code>YOLOv2</code>在标准检测任务如<code>PASCAL VOC</code>和<code>COCO</code>上达到了最先进的水平，并且可以通过多尺度训练方法在不同大小上运行，从而在速度和准确性之间提供简单的权衡。在<code>67 FPS</code>的速度下，<code>YOLOv2</code>在<code>VOC 2007</code>上达到了<code>76.8 mAP</code>，而在<code>40 FPS</code>的速度下达到了<code>78.6 mAP</code>，超过了<code>Faster R-CNN</code>和<code>SSD</code>等其他先进方法。此外，作者提出了一种联合训练方法，可以在目标检测和分类数据上同时训练<code>YOLO9000</code>，使其能够预测那些没有标记检测数据的目标类别。在<code>ImageNet</code>检测验证集上，尽管只有<code>44</code>个类别有检测数据，<code>YOLO9000</code>仍然达到了<code>19.7 mAP</code>，并且在不在<code>COCO</code>中的<code>156</code>个类别上达到了<code>16.0 mAP</code>。<code>YOLO9000</code>能够在实时中检测超过<code>9000</code>个不同的目标类别。</p><h3 id="平均精度均值-⌊mAP⌉">平均精度均值 ⌊mAP⌉</h3><p>  <code>mAP</code>（<code>mean Average Precision</code>，平均精度均值）是目标检测领域常用的性能指标，用于衡量检测模型的整体性能。目标检测问题中的每个图片都可能包含一些不同类别的物体，需要评估模型的物体分类和定位性能。因此，不能用图像分类问题的标准指标 <code>Precision</code> 来简单评估模型性能。</p><p>  <code>mAP</code> 是多个分类任务的 <code>AP</code> 的平均值，而 <code>AP（average precision）</code> 是 <code>PR</code> 曲线下的面积。在介绍 <code>mAP</code> 之前，有必要先介绍 <code>PR</code> 曲线。</p><h4 id="P-R-曲线">P-R 曲线</h4><h5 id="1-TP、FP、FN-和-TN">1. TP、FP、FN 和 TN</h5><p>  这些术语通常用于评估分类模型的性能。通过这些指标，可以计算出模型的准确率、查全率、精确率等其他指标。</p><table><thead><tr><th>术语</th><th>定义</th><th>含义</th></tr></thead><tbody><tr><td>TP (True Positive)</td><td>真正例</td><td>模型正确地将正例预测为正例</td></tr><tr><td>FP (False Positive)</td><td>假正例</td><td>模型错误地将负例预测为正例</td></tr><tr><td>FN (False Negative)</td><td>假负例</td><td>模型错误地将正例预测为负例</td></tr><tr><td>TN (True Negative)</td><td>真负例</td><td>模型正确地将负例预测为负例</td></tr></tbody></table><h5 id="2-查准率、查全率">2. 查准率、查全率</h5><ul><li><strong>查准率</strong>（<code>Precision</code>）<br><br>$$Precision = \frac{TP}{TP+FP}$$<br>说明：查准率关注的是预测结果的准确性，即在所有被预测为正例的样本中，有多少是真正的正例；</li><li><strong>查全率</strong>（<code>Recall</code>）<br><br>$$Recall = \frac{TP}{TP+FN}$$<br>说明：查全率关注的是模型对正例的识别能力，即在所有实际为正例的样本中，有多少被正确识别出来。查全率亦可称<strong>召回率</strong>。</li></ul><p>  根据查准率（<code>P</code>）和查全率（<code>R</code>）绘制的曲线即 <code>P-R</code> 曲线：</p><p><img src="/img/in_posts/YOLO/YOLO_v2/image.png" alt="yolo_v1: Picasso Dataset precision-recall curves."></p><h4 id="AP-的计算">AP 的计算</h4><p>  <code>AP</code> 是计算某一类 <code>P-R</code> 曲线下的面积，计算<code>AP</code> 有两类方法，以下面的 <code>P-R</code> 曲线为例：</p><h5 id="11-点插值法">11 点插值法</h5><ol><li>将检测结果按照置信度从高到低排序；</li><li>计算每个检测结果对应的准确率（<code>Precision</code>）和查全率（<code>Recall</code>）；</li><li>在查全率从<code>0</code>到<code>1</code>的区间内<strong>均匀</strong>选择<code>11</code>个点（<code>0</code>, <code>0.1</code>, <code>0.2</code>, …, <code>1</code>）；</li><li>对于每个查全率点，找到该点<strong>右侧（包括该点）的最大准确率值</strong>；</li><li>计算这<code>11</code>个最大准确率值的平均值，作为<code>AP</code>。</li></ol><p><img src="/img/in_posts/YOLO/YOLO_v2/image-1.png" alt="11 点插值法"></p><p>  <code>11</code>点插值法在早期的信息检索和目标检测领域中被广泛使用，尤其是在<code>PASCAL VOC</code>数据集的早期版本中（如<code>VOC2007</code>和<code>VOC2008</code>）。这种方法简单易实现，但精度较低，因为它只考虑了<code>11</code>个固定的查全率点.</p><h5 id="积分法">积分法</h5><ol><li>对检测结果按置信度从高到低排序，计算每个结果对应的准确率和查全率；</li><li>将准确率序列调整为单调不增；</li><li>对于每个查全率值，找到其<strong>大于等于该值时的最大准确率</strong>；</li><li>计算这些最大准确率值与对应的查全率差值的乘积之和，即为<code>AP</code>。</li></ol><p><img src="/img/in_posts/YOLO/YOLO_v2/image-2.png" alt="积分法"></p><h4 id="mAP-的计算">mAP 的计算</h4><p>  <code>AP</code> 是计算某一类 <code>P-R</code> 曲线下的面积，<code>mAP</code> 则是计算所有类别 <code>P-R</code> 曲线下面积的<strong>平均值</strong>。</p><p>$$mAP = \frac{\sum_{c \in classes} AP_{c}}{N(classes)}$$</p><h3 id="YOLOv1-的不足">YOLOv1 的不足</h3><p>  <code>YOLOv1</code>在检测精度上存在不足，尤其是在<code>mAP</code>（平均精度均值）方面。主要缺点包括：</p><ol><li><p><strong>定位误差</strong><br><code>YOLOv1</code>在定位目标时容易出现误差。与基于区域建议的方法（如<code>Faster R-CNN</code>）相比，<code>YOLOv1</code>的定位精度较低，这导致其<code>mAP</code>值相对较低；</p></li><li><p><strong>查全率较低</strong><br><code>YOLOv1</code>的查全率相对较低，这意味着它可能会漏掉一些实际存在的目标。查全率的不足也会影响<code>mAP</code>的计算，因为<code>mAP</code>是基于精度和查全率的综合指标；</p></li><li><p><strong>对小目标的检测能力不足</strong><br><code>YOLOv1</code>在检测小目标方面表现不佳，因为它使用的是较为粗糙的特征图进行检测，难以准确捕捉小目标的细节。</p></li></ol><p>  这些不足使得<code>YOLOv1</code>在一些标准检测任务（如<code>PASCAL VOC</code>和<code>COCO</code>）上的<code>mAP</code>表现不如一些基于区域建议的先进方法。因此，<code>YOLOv2</code>在这些方面进行了改进，以提高检测的精度和查全率，从而提升了<code>mAP</code>值。</p><h2 id="引言-⌊Introduction⌉">引言 ⌊Introduction⌉</h2><p>  引言部分，作者讨论了通用目标检测面临的挑战和机遇：</p><ol><li><p><strong>目标检测的需求</strong><br>通用目标检测应该具备快速、准确和能够识别广泛种类目标的特点。随着神经网络的发展，检测框架在速度和准确性上都有了显著提升，但在目标种类的识别上仍然受到限制。</p></li><li><p><strong>数据集的限制</strong><br>当前的目标检测数据集（如<code>PASCAL VOC</code>和<code>COCO</code>）与分类数据集（如<code>ImageNet</code>）相比规模较小。检测数据集通常包含数千到数十万张图像，而分类数据集则包含数百万张图像和数十万到数百万个类别。<strong>检测数据的标注成本远高于分类数据</strong>，因此不太可能在短期内看到与分类数据集规模相当的检测数据集。</p></li><li><p><strong>YOLO9000的目标</strong><br>作者提出了一种新方法，<strong>利用已有的大量分类数据来扩展当前检测系统的范围</strong>。通过使用层次化的对象分类视图，可以将不同的数据集结合起来。此外，作者还提出了一种<strong>联合训练算法</strong>，可以在检测和分类数据上同时训练目标检测器。这种方法利用检测数据来精确定位目标，同时使用分类数据来增加词汇量和鲁棒性。</p></li><li><p><strong>YOLO9000的实现</strong><br>通过这些方法，作者训练了<code>YOLO9000</code>，这是一个实时目标检测器，能够检测超过<code>9000</code>个不同的目标类别。首先，他们改进了基础的<code>YOLO</code>检测系统，开发出<code>YOLOv2</code>，这是一个先进的实时检测器。然后，他们使用<strong>数据集组合方法</strong>和<strong>联合训练算法</strong>，训练了一个能够在<code>ImageNet</code>的<code>9000</code>多个类别以及<code>COCO</code>的检测数据上运行的模型。</p></li></ol><h2 id="更好-⌊Better⌉">更好 ⌊Better⌉</h2><p>  <code>YOLO</code>在定位和查全率方面存在不足，而<code>YOLOv2</code>通过简化网络结构和优化学习表示，提高了定位精度和召回率，同时保持了快速的检测速度。从 <code>YOLOv1</code> 到 <code>YOLOv2</code> 结合了过去的研究成果和一些新概念，使得<code>YOLOv2</code>在性能上取得了显著提升：</p><p><img src="/img/in_posts/YOLO/YOLO_v2/image-3.png" alt="从 YOLOv1 到 YOLOv2"></p><h3 id="1-批归一化-⌊Batch-Normalization⌉">1. 批归一化 ⌊Batch Normalization⌉</h3><p>  <code>Batch Normalization</code> 往往用于在深度神经网络中激活层之前，可以加快模型训练时的收敛速度，使得模型训练过程更加稳定，避免梯度爆炸或者梯度消失。</p><p>  <code>Batch Normalization</code> 核心公式：<br>$$\begin{aligned} Input:\ B = {x_{1…m}};\ \gamma,\ \beta \\ Output:\ {y_i = BN_{\gamma, \beta}(x_i) } \\ \mu_B \leftarrow \frac{1}{m} \sum_{i = 1}^m x_i \\ \sigma^2_{B} \leftarrow \frac{1}{m} \sum_{i=1}^m (x_i - \mu_B)^2 \\ \tilde{x} \leftarrow \frac{x_i - \mu_B}{\sqrt{\sigma^2 +\epsilon}} \\ y_i \leftarrow \gamma \tilde{x} + \beta \end{aligned}$$</p><p>解释：</p><ol><li><p><strong>输入</strong>:</p><ul><li>$ B = {x_{1…m}} $: 一批输入数据，其中 $ x_i $ 是第 $ i $ 个输入，$ m $ 是批大小。</li><li>$ \gamma $, $ \beta $: 两个可学习的参数，分别用于缩放和偏移归一化后的数据。</li></ul></li><li><p><strong>输出</strong>:</p><ul><li>$ {y_i = BN_{\gamma, \beta}(x_i) } $: 经过批归一化后的输出数据。</li></ul></li><li><p><strong>步骤</strong>:</p><ul><li><p><strong>计算均值</strong>:<br>$$<br>\mu_B \leftarrow \frac{1}{m} \sum_{i = 1}^m x_i<br>$$<br>计算这批数据的均值 $\mu_B$。</p></li><li><p><strong>计算方差</strong>:<br>$$<br>\sigma^2_{B} \leftarrow \frac{1}{m} \sum_{i=1}^m (x_i - \mu_B)^2<br>$$<br>计算这批数据的方差 $\sigma^2_{B}$。</p></li><li><p><strong>归一化</strong>:<br>$$<br>\tilde{x} \leftarrow \frac{x_i - \mu_B}{\sqrt{\sigma^2 +\epsilon}}<br>$$<br>将每个输入 $x_i$ 归一化，使其均值为<code>0</code>，方差为<code>1</code>。其中 $\epsilon$ 是一个很小的常数，用于防止分母为零。</p></li><li><p><strong>缩放和偏移</strong>:<br>$$<br>y_i \leftarrow \gamma \tilde{x} + \beta<br>$$<br>对归一化后的数据 $\tilde{x}$ 进行缩放和偏移，得到最终的输出 $y_i$。</p></li></ul></li></ol><p><code>Batch Normalization</code>批归一化确保了每批数据的分布更加稳定，从而加速了模型的训练过程并提高了模型的泛化能力。</p><p>  通过在 <code>YOLO</code> 中的所有卷积层上添加批量归一化，使得 <code>YOLO</code> 在 <code>mAP</code> 指标上获得了 <code>2% </code>以上的改进。通过批归一化，可以在不过度拟合的情况下从模型中删除 <code>dropout</code>。</p><h3 id="2-高分辨率分类器-⌊High-Resolution-Classifier⌉">2. 高分辨率分类器 ⌊High Resolution Classifier⌉</h3><p>  <code>YOLOv1</code>的分类器网络在<code>224x224</code>分辨率下进行训练，然后在检测时将分辨率提高到<code>448x448</code>。这种突然的分辨率变化使得网络需要同时适应新的输入分辨率和学习目标检测任务，导致性能受限。</p><p>  为了改进这一点，<code>YOLOv2</code>采取了以下步骤进行优化：</p><ol><li><p><strong>预训练阶段</strong><br>在<code>ImageNet</code>数据集上，首先将分类器网络在<code>448x448</code>的高分辨率下进行预训练。这样做的目的是让网络有足够的时间调整其滤波器（<code>filters</code>），以更好地适应高分辨率的输入图像。通过这种方式，<u>网络可以在检测任务开始之前，就已经具备了处理高分辨率图像的能力</u>；</p></li><li><p><strong>微调阶段</strong><br>在完成高分辨率下的分类器预训练之后，再将得到的网络用于目标检测任务的微调。此时，网络已经在高分辨率下具备了良好的特征提取能力，因此在检测任务中能够更准确地定位和识别目标。</p></li></ol><p>  通过这种<strong>高分辨率分类器</strong>的改进方法，<code>YOLOv2</code>在检测任务中的平均精度（<code>mAP</code>）得到了显著提升，具体来说，相比之前的方法提高了将近<code>4%</code>的<code>mAP</code>。这表明，<u>通过让网络在高分辨率下进行充分的预训练，可以有效地提高其在目标检测任务中的性能，尤其是在定位精度方面</u>。</p><h3 id="3-带锚框的卷积-⌊Convolutional-With-Anchor-Boxes⌉">3. 带锚框的卷积 ⌊Convolutional With Anchor Boxes⌉</h3><h4 id="什么是锚框-Anchor-Boxes">什么是<strong>锚框</strong> <code>Anchor Boxes</code></h4><p>  <strong>锚框</strong>（<code>Anchor Boxes</code>）最初在<code>Faster R-CNN</code>中被引入。其<strong>基本思想</strong>是在特征图的<strong>每个位置上预定义一组不同尺寸和宽高比的边界框</strong>，这些预定义的边界框被称为锚框。<strong>网络的任务是调整这些锚框以更好地匹配图像中的真实目标</strong>。</p><h4 id="为什么要引入锚框Anchor-Boxes">为什么要引入锚框<code>Anchor Boxes</code></h4><p>  由于<code>YOLOv1</code>直接预测边界框的<strong>绝对坐标</strong>，这在学习过程中容易导致不稳定，尤其是在预测边界框的大小和位置时，这就导致 <code>YOLOv1</code> 在定位精度方面存在局限。</p><p>  而调整锚框相当于在预定义的边界框的基础上进行微调，<strong>只需要预测相对于锚框的偏移量</strong>（比如中心点的偏移，宽度和高度的缩放比例），这使得学习任务更加简单和直观。因为<u>网络不需要从零开始学习边界框的绝对位置和大小，而是专注于如何调整已有的框以更好地匹配目标，降低了学习难度</u>。</p><p>  此外，使用锚框可以生成更多的候选框，覆盖图像中的多种目标尺寸和形状。这使得检测模型能够更好地捕捉到目标，从而<strong>提高查全率</strong>。即使某些目标的尺寸或形状与预定义的锚框不完全匹配，网络也可以通过调整锚框的偏移量来适应这些目标。</p><h4 id="具体是怎么做的">具体是怎么做的</h4><ol><li><p><strong>移除全连接层</strong><br><code>YOLOv1</code>使用全连接层直接预测边界框的坐标，而<code>YOLOv2</code><strong>移除了全连接层，改为使用卷积层来预测边界框</strong>。这使得<code>YOLOv2</code>可以在特征图的每个位置上进行边界框的预测，而不是仅限于固定的网格单元；</p></li><li><p><strong>引入锚框</strong><br>网络预测相对于锚框的偏移量和置信度，而不是直接预测边界框的绝对坐标；</p></li><li><p><strong>提高特征图分辨率</strong><br>为了更好地检测小目标，<code>YOLOv2</code>去除了一个池化层，使得网络的卷积层输出具有更高的分辨率（池化层会降低特征图的空间维度，即宽和高）。同时，将输入图像的尺寸从<code>448x448</code>调整为<code>416x416</code>，以获得一个<code>13x13</code>的输出特征图。这种调整使得特征图的中心位置能够更准确地预测大目标；</p><blockquote><p>即现在图像会被划分为 $S \times S = 13 \times 13$ 的网络，而不是 <code>YOLOv1</code> 中的 $S = 7$。为什么是网格划分都是奇数？奇数网格划分可以确保边界框中心有一个单独的网格单元，有利于精确定位目标的中心，提高检测精度.</p></blockquote></li><li><p><strong>解耦类别预测和空间位置预测</strong><br>在<code>YOLOv1</code>中，类别预测和空间位置预测是耦合在一起的。<code>YOLOv2</code>将这两者解耦，使得每个锚框都有自己的类别预测和置信度预测。置信度预测仍然是预测真实框和预测框的<code>IOU</code>，而类别预测则是预测在存在目标的情况下该类别的条件概率。</p></li></ol><h4 id="引入锚框带来什么效果">引入锚框带来什么效果</h4><p>  使用锚框后，<code>YOLOv2</code>的<code>mAP</code><strong>略有下降</strong>，从<code>69.5%</code>降至<code>69.2%</code>，但查全率（<code>Recall</code>）从<code>81%</code>提高到<code>88%</code>。虽然<code>mAP</code>有所下降，但查全率的提高为模型的进一步优化提供了更大的空间，因为模型能够检测到更多的目标。</p><h4 id="YOLOv1-和-YOLOv2-对比">YOLOv1 和 YOLOv2  对比</h4><table><thead><tr><th></th><th>$YOLOv1$</th><th>$YOLOv2$</th></tr></thead><tbody><tr><td>初始设定</td><td>初始每个网格单元预测<code>2</code>个边界框以及一组类别概率，其中类别概率由该 <code>2</code> 个边界框共享</td><td>初始时每个网格单元设定固定的 <code>5</code> 个锚框，并且每个位置的锚框都单独预测一组类别概率值</td></tr><tr><td>预测结果公式</td><td>$S\times S\times (B*5+C)$</td><td>$S\times S\times A\times (5+C)$</td></tr><tr><td>公式说明</td><td><code>YOLOv1</code> 中，每张图像被划分为 $S = 7$ 的网络，而每个网格单元预测$B=2$个边界框和 $C$ 个类别概率，每个边界框均预测 <code>5</code> 个值：<code>x</code>、<code>y</code>、<code>w</code>、<code>h</code> 和 <code>置信度</code>。并且每个网格单元的所有边界框<strong>共享</strong>这一组类别概率</td><td><code>YOLOv2</code>中，每张图像被划分为$S=13$的网络，初始时设定固定数量的 $A=5$ 个锚框，并且每个位置的锚框都单独预测一组类别概率，同样每个锚框预测 <code>5</code> 个值：<code>tx</code>、<code>ty</code>、<code>tw</code>、<code>th</code> （即预测相对于锚框的<strong>偏移量</strong>）和<code>置信度</code></td></tr><tr><td>输出框数量</td><td>$7\times 7\times 2 = 98$</td><td>$13\times 13\times 5 = 845$</td></tr><tr><td>输出张量</td><td>$7\times 7\times 30$</td><td>$13\times 13\times 125$</td></tr></tbody></table><p><img src="/img/in_posts/YOLO/YOLO_v2/image-4.png" alt="输出张量对比"></p><h3 id="4-维度集群-⌊Dimension-Clusters⌉">4. 维度集群 ⌊Dimension Clusters⌉</h3><h4 id="什么是维度聚类-Dimension-Clusters">什么是<strong>维度聚类</strong> Dimension Clusters</h4><p>  <strong>维度聚类</strong><code>Dimension Clusters</code>是一种用于优化目标检测中锚框尺寸选择的方法。它通过在训练数据集的边界框尺寸上进行聚类分析，自动选择一组能够较好地覆盖数据集中目标尺寸分布的锚框尺寸。</p><h4 id="为什么要引入-Dimension-Clusters">为什么要引入 Dimension Clusters</h4><p>  在目标检测中，<strong>使用锚框的一个关键挑战是如何选择合适的锚框尺寸</strong>。如果锚框的尺寸与数据集中目标的实际尺寸差异较大，网络需要花费更多的努力来调整这些锚框以匹配目标，从而影响检测性能。</p><ul><li><strong>手动选择的局限性</strong><br>在<code>Faster R-CNN</code>等早期方法中，锚框的尺寸通常是手动选择的，这依赖于经验，并且可能无法很好地匹配数据集中目标的实际尺寸分布；</li><li><strong>提高检测精度</strong><br>通过自动选择更合适的锚框尺寸，可以使网络更容易学习如何调整锚框以匹配目标，从而提高检测的精度和效率。</li></ul><h4 id="如何引入Dimension-Clusters">如何引入Dimension Clusters</h4><p>  <code>YOLOv2</code>通过以下步骤引入了<code>Dimension Clusters</code>：</p><ol><li><strong>数据预处理</strong><br>首先，从训练集中提取所有标注的边界框的尺寸（宽度和高度）;</li><li><strong>k-means聚类</strong><br>在这些边界框的尺寸上运行<code>k-means</code>聚类算法。与传统的欧氏距离不同，这里使用基于<code>IOU</code>（交并比）的距离度量来计算边界框之间的相似性。具体来说，<strong>距离度量</strong>定义为：<br>$$d(box, centroid) = 1 - \text{IOU}(box, centroid)$$<br>这种距离度量方式使得聚类结果更符合检测任务的需求，即最大化预测框与真实框的重叠度;</li><li><strong>选择聚类中心</strong><br>通过调整聚类的数量（<code>k</code>值），选择一组能够较好地覆盖数据集中目标尺寸分布的聚类中心作为锚框的尺寸。在<code>YOLOv2</code>中，最终选择了<code>k=5</code>作为聚类的数量，这在模型复杂度和检测性能之间取得了较好的平衡。</li></ol><p><img src="/img/in_posts/YOLO/YOLO_v2/image-5.png" alt="VOC和COCO上的聚类框尺寸"></p><blockquote><p>为什么不是 <code>K</code> 越大越好？<br>随着 <code>k</code> 的增加，模型需要处理的锚框数量也会增加，这会导致计算量显著上升。每个锚框都需要进行位置、大小和置信度的预测，计算量的增加会降低模型的运行速度，尤其是在实时检测任务中，这可能会影响模型的实用性.</p></blockquote><h4 id="引入后的效果">引入后的效果</h4><ul><li><strong>提高平均IOU</strong><br>通过使用基于<code>IOU</code>的聚类方法，得到的锚框尺寸与数据集中目标的实际尺寸更加匹配。在<code>VOC 2007</code>数据集上，使用聚类得到的锚框尺寸，模型与真实框的平均<code>IOU</code>从手动选择锚框时的<code>60.9%</code>提高到了<code>61.0%</code>，而使用<code>9</code>个聚类中心时，平均<code>IOU</code>进一步提高到<code>67.2%</code>;</li><li><strong>提升检测性能</strong><br>由于锚框尺寸更加合适，网络在调整锚框以匹配目标时变得更加容易，从而提高了检测的精度;</li><li><strong>简化模型训练</strong><br>使用基于数据的聚类结果作为锚框尺寸，使得模型训练过程更加稳定和高效，因为网络不需要花费过多的精力去调整不合适尺寸的锚框。</li></ul><h3 id="5-直接位置预测-⌊Direct-location-prediction⌉">5. 直接位置预测 ⌊Direct location prediction⌉</h3><h4 id="为什么需要进行直接的位置预测">为什么需要进行直接的位置预测</h4><p>  使用锚框<code>Anchor Boxes</code> 带来的第二个问题是：模型不稳定，特别是在早期迭代期间。大多数不稳定性来自于对边界框中心位置<code>(x, y)</code>的预测。</p><p>  在使用<strong>区域提议</strong>的网络中，网络预测边界框相对于锚框的偏移量 <code>tx</code> 和<code>ty</code>，中心位置 <code>(x, y)</code> 坐标计算如下：</p><p>$$\begin{aligned}x = (t_x * w_a) + x_a \\ y = (t_y * h_a) + y_a \\ 其中，\\ w_a 是锚框的宽度 \\ h_a 是锚框的高度 \\ (x_a, y_a) 是锚框的中心位置坐标 \end{aligned}$$</p><blockquote><p>论文中这里使用了减法，这应该是一个错误。因为 $$初始锚框中心坐标(x_a, y_a) + 偏移量 = 预测的边界框的中心坐标$$</p></blockquote><p>例如，当 $t_x = 1$ 时，就是将边界框向右移动一个锚框宽度 $w_a$ 的距离；而 $t_x = -1$ 时，就是将边界框向左移动一个锚框宽度 $w_a$ 的距离。</p><p>  这个公式存在局限性：</p><ol><li><strong>初始权重的影响</strong><br>在训练初期，网络的权重通常是随机初始化的。这可能导致预测的偏移量 $(t_x, t_y)$ 在初始阶段波动较大，从而使得预测的边界框中心坐标不稳定。尤其是在偏移量的预测值较大或较小的情况下，边界框的位置可能会偏离真实目标较远，影响模型的训练过程和收敛速度；</li><li><strong>无界性</strong><br>虽然理论上偏移量$(t_x, t_y)$， 应该是相对于锚框的相对位置，但在实际训练过程中，如果没有适当的约束和正则化，偏移量可能会变得非常大，导致预测的边界框位置不合理，从而影响检测的准确性.\</li></ol><h4 id="YOLOv2-是怎么做的">YOLOv2 是怎么做的</h4><h5 id="直接预测边界框的中心位置">直接预测边界框的中心位置</h5><ol><li><strong>相对于网格单元的绝对位置</strong><br><code>YOLOv2</code>直接预测边界框中心点在网格单元内的<strong>绝对位置</strong>，而不是预测相对于锚框中心的偏移量。具体来说，网络预测的中心点坐标是相对于网格单元左上角的相对坐标 $ (bx, by) $，使用$sigmoid$ <strong>激活函数</strong>将其约束在<code>0</code>到<code>1</code>之间，<u>表示边界框中心点在网格单元内的相对位置</u>；</li><li><strong>计算公式</strong><br>对于每个网格单元，假设其左上角坐标为 $(c_x, c_y)$，则边界框中心点的绝对坐标 $(x, y)$ 通过以下公式计算：</li></ol><p>$$\begin{aligned}b_x = \sigma(t_x) + c_x \\ b_y = \sigma(t_y) + c_y \\ (tx, ty) 是网络预测的相对偏移量 \\ (c_x, c_y) 是网格单元的左上角坐标 \\ \sigma 是sigmoid激活函数 \end{aligned}$$</p><blockquote><p><strong>直接</strong> 是如何体现的？为什么网络仍然预测了相对偏移量？ <br> <strong>直接</strong>体现在<strong>最终输出的边界框中心坐标是相对于整个图像的绝对坐标，而不是相对于锚框的相对位置</strong>。虽然在实际计算过程中，网络预测的是相对于网格单元的相对偏移量 $(t_x,t_y)$，但通过与网格单元的位置信息结合，最终得到的是边界框的绝对位置</p></blockquote><h5 id="预测边界框的宽度和高度">预测边界框的宽度和高度</h5><ol><li><strong>相对于锚框的缩放比例</strong><br>虽然<code>YOLOv2</code>直接预测边界框的中心位置，但在预测边界框的宽度和高度时，<strong>仍然使用锚框作为初始估计</strong>。网络预测的是相对于锚框的缩放比例 $(t_w, t_h)$，即预测框的宽度和高度相对于锚框的宽度和高度的缩放比例.</li><li><strong>计算公式</strong><br>假设锚框的宽度和高度分别为 $P_w$ 和 $P_h$，则预测框的宽度和高度可以通过以下公式计算：<br>$$ \begin{aligned} b_w = P_w e^{t_w} \\ b_h = P_h e^{t_h} \end{aligned}$$<br>其中，$(t_w, t_h)$ 是网络预测的缩放比例.</li></ol><p><img src="/img/in_posts/YOLO/YOLO_v2/image-6.png" alt="具有维度先验和位置预测的边界框"></p><h4 id="达到了什么效果">达到了什么效果</h4><p>  由于约束位置预测，参数化更容易学习，使网络更加稳定。使用维度集群以及直接预测边界框中心位置比带有锚框的版本提高了近 <code>5%</code>。</p><h3 id="6-细粒度特征-⌊Fine-Grained-Features⌉">6. 细粒度特征 ⌊Fine-Grained Features⌉</h3><h4 id="What（是什么）">What（是什么）</h4><p>  在<code>YOLOv2</code>中，<strong>细粒度特征</strong>是指<u>通过结合更高分辨率的特征图来增强模型对小目标的检测能力</u>。具体来说，<code>YOLOv2</code>使用一个<code>passthrough</code>层将<code>26x26x512</code>的特征图转换为<code>13x13x2048</code>的特征图，并将其与原始的<code>13x13x1024</code>特征图拼接，形成一个更大的特征图用于检测器的输入。</p><h4 id="Why（为什么）">Why（为什么）</h4><ul><li><strong>提高对小目标的检测能力</strong><br>小目标在图像中占据的像素面积较小，直接在低分辨率的特征图上进行检测可能会丢失重要的细节特征，导致检测精度下降。引入细粒度特征可以捕捉到更多的细节信息，从而更好地定位和识别小目标.</li><li><strong>增强特征的表达能力</strong><br>通过结合不同尺度的特征信息，细粒度特征能够提供更丰富的空间信息和纹理信息，使得模型能够更准确地识别目标的轮廓和形状，增强对目标的综合表达能力.</li></ul><h4 id="How（如何实现）">How（如何实现）</h4><ul><li><strong>Passthrough层的使用</strong><br><code>YOLOv2</code>引入了一个<code>passthrough</code>层，将<code>26x26x512</code>的特征图通过<strong>堆叠相邻特征</strong>的方式转换为<code>13x13x2048</code>的特征图。这种转换类似于<code>ResNet</code>中的恒等映射，<strong>通过将相邻特征堆叠到不同的通道中，保留了更多的细节信息</strong>.</li><li><strong>特征图的拼接</strong><br>将转换后的<code>13x13x2048</code>特征图与原始的<code>13x13x1024</code>特征图进行拼接，形成一个更大的特征图，用于检测器的输入。这样，检测器<strong>可以同时利用不同尺度的特征信息</strong>，提高检测的精度和鲁棒性.</li></ul><p><img src="/img/in_posts/YOLO/YOLO_v2/image-7.png" alt="具有维度先验和位置预测的边界框"></p><h4 id="效果如何">效果如何</h4><ul><li><strong>提升检测性能</strong><br>引入细粒度特征后，<code>YOLOv2</code>在检测小目标方面的性能得到了显著提升。虽然这种改进带来的性能提升相对较小（大约<code>1%</code>的<code>mAP</code>提升），但它对于提高模型在实际应用中的鲁棒性和准确性具有重要意义，尤其是在需要检测大量小目标的场景中.</li><li><strong>增强对小目标的适应性</strong><br>通过捕捉更多的细节信息，<code>YOLOv2</code>能够更好地适应不同尺寸和形状的小目标，提高了对小目标的检测精度和查全率，使其在各种检测任务中表现得更加出色.</li></ul><h3 id="7-多尺度训练-⌊Multi-Scale-Training⌉">7. 多尺度训练 ⌊Multi-Scale Training⌉</h3><h4 id="What（是什么）-2">What（是什么）</h4><p>  <strong>多尺度训练</strong>：在训练过程中，<code>YOLOv2</code>不是固定输入图像的尺寸，而是随机改变输入图像的尺寸。具体来说，每隔<code>10</code>个批次，网络会随机选择一个新的图像尺寸进行训练。</p><h4 id="Why（为什么）-2">Why（为什么）</h4><ul><li><strong>提高模型的鲁棒性</strong><br>通过在不同尺寸的图像上进行训练，模型能够学习到在各种输入尺寸下进行检测的能力，从而提高对不同尺寸目标的检测鲁棒性.</li><li><strong>适应不同的应用场景</strong><br>在实际应用中，输入图像的尺寸可能会有很大的变化。多尺度训练使得模型能够更好地适应这些变化，提高在不同场景下的检测性能.</li></ul><h4 id="How（如何实现）-2">How（如何实现）</h4><ul><li><strong>随机选择图像尺寸</strong><br><code>YOLOv2</code>在训练过程中每隔<code>10</code>个批次随机选择一个新的图像尺寸。由于模型的下采样因子为<code>32</code>，因此选择的图像尺寸是<code>32</code>的倍数，范围从<code>320×320</code>到<code>608×608</code>.</li><li><strong>动态调整网络结构</strong><br>根据选择的图像尺寸，动态调整网络的结构，使得网络能够处理不同尺寸的输入图像。这种动态调整使得模型在训练过程中能够学习到不同尺度下的特征表示.</li></ul><p><img src="/img/in_posts/YOLO/YOLO_v2/image-8.png" alt="多尺度训练"></p><h4 id="效果如何-2">效果如何</h4><p>  多尺度训练使得<code>YOLOv2</code>能够在不同的输入尺寸下提供速度与精度之间的权衡。在较小的输入尺寸下，模型运行速度更快，虽然精度略有下降，但仍然能够保持较高的检测性能；在较大的输入尺寸下，模型能够达到更高的精度，同时仍然保持实时的检测速度。</p><h3 id="8-总结">8. 总结</h3><p>  经过一系列改进，如批归一化、高分辨率分类器、使用锚框、维度聚类、直接位置预测、细粒度特征和多尺度训练等，<code>YOLO</code>模型从<code>YOLOv1</code>进步到了<code>YOLOv2</code>，这些优化措施显著提升了检测速度、精度和对不同尺寸目标的适应性，使<code>YOLOv2</code>成为一个更加强大和高效的目标检测模型：</p><p><img src="/img/in_posts/YOLO/YOLO_v2/image-11.png" alt="VOC 2007 的准确性和速度对比"></p><h2 id="更快-⌊Faster⌉">更快 ⌊Faster⌉</h2><p>  <code>YOLOv2</code>提出了<code>Darknet-19</code>（有<code>19</code>个卷积层和<code>5</code>个<code>MaxPooling</code>层）网络结构作为特征提取网络。<code>DarkNet-19</code>比<code>VGG-16</code>小一些，精度不弱于<code>VGG-16</code>，但浮点运算量减少到约$\frac{1}{5}$，以保证更快的运算速度。</p><p><img src="/img/in_posts/YOLO/YOLO_v2/image-9.png" alt="Darknet-19"></p><p>  <code>YOLOv2</code>的网络中只有<code>卷积+pooling</code>，从<code>416x416x3</code> 变换到 <code>13x13x5x25</code>。增加了<code>batch normalization</code>，增加了一个<code>passthrough</code>层，去掉了全连接层，以及采用了<code>5</code>个锚框,网络的输出如下图所示：</p><p><img src="/img/in_posts/YOLO/YOLO_v2/image-10.png" alt="网络输出"></p><h2 id="更强-⌊Stronger⌉">更强 ⌊Stronger⌉</h2><h3 id="YOLOv2-与-YOLO9000">YOLOv2 与 YOLO9000</h3><p>  <code>YOLOv2</code>是<code>YOLO</code>系列目标检测模型的一个重要改进版本，通过一系列优化措施提升了检测速度和精度。而<code>YOLO9000</code>则是在<code>YOLOv2</code>的基础上进一步扩展，采用联合训练方法和基于<code>WordNet</code>的层次化分类结构（<code>WordTree</code>），将不同数据集的类别标签映射到一个统一的层次结构中，使其能够检测超过<code>9000</code>个不同的目标类别，从而在类别检测能力和应用场景上实现了显著扩展，两者共同推动了<code>YOLO</code>系列模型的发展。</p>]]></content>
    
    
    <categories>
      
      <category>目标检测</category>
      
      <category>YOLO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PaperShare</tag>
      
      <tag>YOLO</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YOLO v1 论文分享</title>
    <link href="/2025/01/01/YOLO/YOLO_v1/"/>
    <url>/2025/01/01/YOLO/YOLO_v1/</url>
    
    <content type="html"><![CDATA[<h2 id="You-Only-Look-Once-Unified-Real-Time-Object-Detection">$You\ Only\ Look\ Once:\ Unified,\ Real-Time\ Object\ Detection$</h2><blockquote><p><a href="https://arxiv.org/abs/1506.02640">论文链接</a><br><a href="https://pjreddie.com/darknet/yolo/">项目地址</a></p></blockquote><h3 id="摘要-⌊Abstract⌉">摘要 ⌊Abstract⌉</h3><ul><li><strong>YOLO介绍</strong><br>提出了一种名为 <code>YOLO</code> 的新方法，用于目标检测（<code>object detection</code>）。这种方法将目标检测视为一个<strong>回归问题</strong>，直接从整张图像预测边界框和类别概率，而不是重新利用分类器进行检测（之前工作的主要方向）。</li></ul><blockquote><p><strong>边界框</strong>（<code>Bounding Box</code>）是目标检测中用于定位图像内目标位置的矩形区域，用于确定目标的确切位置、进行分类以及评估预测的准确性，常以不同颜色或样式的矩形框在图像上显示，便于可视化分析。在<code>YOLO</code>算法中，每个网格单元预测多个边界框及其置信度和条件类别概率，实现快速目标检测。</p></blockquote><blockquote><p><strong>类别概率</strong>（<code>class probabilities</code>）是指在机器学习和模式识别任务中，模型对于给定输入样本属于某个特定类别的置信度或概率估计。在目标检测和图像识别等任务中，类别概率尤为重要，因为它们不仅需要识别出图像中的对象，还需要确定这些对象属于哪个类别。<br><br>在<code>YOLO</code>算法中，类别概率是指每个网格单元预测的边界框内包含某个类别目标的概率。这些概率值是<strong>条件概率</strong>，即在网格单元内确实存在目标的条件下（所以与边界框的置信度是由关联的），边界框包含特定类别目标的概率。通过这种方式，<code>YOLO</code>能够同时预测目标的位置和类别，实现快速且准确的目标检测。</p></blockquote><ul><li><strong>速度与性能</strong><br><code>YOLO</code>的统一架构非常快速，基础模型能够以每秒<code>45</code>帧的速度实时处理图像。还有一个更小的版本，<code>Fast YOLO</code>，能够达到惊人的每秒<code>155</code>帧，同时在平均精度均值（<code>mAP</code>）上是其他实时检测器的两倍。</li><li><strong>准确性与泛化</strong><br>与最先进的检测系统相比，<code>YOLO</code>在目标定位上可能会犯更多错误，但不太可能在背景上预测出错误的正例。此外，<code>YOLO</code>学习到的目标表示具有很好的泛化能力，当从自然图像泛化到其他领域（如艺术品）时，其表现优于其他检测方法，包括<code>DPM</code>和<code>R-CNN</code>。</li></ul><h3 id="引言-⌊Introduction⌉">引言 ⌊Introduction⌉</h3><p>  论文引言部分，作者总结了之前目标检测算法使用的主要方法：</p><h4 id="之前的目标检测算法主要方法">之前的目标检测算法主要方法</h4><ol><li><p><strong>分类器再利用</strong><br>以往的系统通常将分类器用于检测任务，通过在测试图像的不同位置和尺度上评估分类器来检测对象。</p></li><li><p><strong>滑动窗口方法</strong><br>如可变形部件模型（<code>Deformable Parts Models</code>, <code>DPM</code>），它们使用滑动窗口方法，在图像的固定间隔位置上运行分类器。</p></li><li><p><strong>区域提议方法</strong><br>如<code>R-CNN</code>系列方法，首先生成潜在的边界框，然后在这些提议的框上运行分类器，之后使用<strong>后处理</strong>来优化边界框和消除重复检测。</p></li></ol><h4 id="YOLO与之前方法的对比">YOLO与之前方法的对比</h4><ol><li><p><strong>统一的框架</strong><br><code>YOLO</code>将目标检测框架为一个单一的回归问题，直接从图像像素预测边界框坐标和类别概率，而不是将分类器用于检测。</p></li><li><p><strong>端到端优化</strong><br><code>YOLO</code>作为一个单一网络，可以端到端直接优化检测性能，而传统方法需要分别训练和优化多个组件。</p></li><li><p><strong>速度</strong><br><code>YOLO</code>的统一架构非常快速，能够实现实时目标检测，而传统方法由于复杂的处理流程，速度较慢。</p></li><li><p><strong>全局推理</strong><br><code>YOLO</code>在训练和测试时能够看到整个图像，隐式编码类别和外观的上下文信息，而传统方法如滑动窗口和区域提议方法只能看到局部信息。</p></li><li><p><strong>泛化能力</strong><br><code>YOLO</code>学习到的目标表示具有很好的泛化能力，能够在不同领域中表现优于其他检测方法。</p></li></ol><h3 id="统一检测-⌊Unified-Detection⌉">统一检测 ⌊Unified Detection⌉</h3><p>  <code>YOLO</code>通过将目标检测的各个环节整合进一个神经网络，实现了利用整张图像的特征来同时预测所有类别的边界框，并进行全局推理，这样的设计使得<code>YOLO</code>不仅能够端到端训练，还能在保持高平均精度的同时达到实时的检测速度。</p><p>  <code>YOLO</code> 将输入的图像划分为 $S \times S$ 网格。<strong>如果物体的中心落入一个网格单元，则该网格单元负责检测该物体</strong>；<br></p><p>  每个网格单元预测<code>B</code>（用<code>B</code>表示是出于<code>Boxes</code>）个边界框以及这些框的置信度分数。这些<strong>置信度分数</strong>反映了模型对于边界框内包含物体的置信度，同时也反映了模型对其边界框准确性的评估。<br>形式上，<code>YOLO</code> 将置信度定义为</p><p>$$Confidence = Pr(Object)*IOU_{pred}^{truth}$$</p><blockquote><p>$Pr(Object)$：模型预测某个边界框包含至少一个对象的概率。$Pr$ 代表概率。</p></blockquote><p>  如果网格单元中不存在物体，则置信度得分应该为 <code>0</code>。否则，置信度得分希望等于边界框与真实值之间的<strong>交并比</strong>（<code>IOU</code>）。</p><blockquote><p>交并比（<code>Intersection Over Union</code>，<code>IOU</code>）是目标检测和图像分割任务中常用的评估指标，用于衡量两个边界框（或区域）之间的重叠程度。<code>IOU</code>计算的是两个边界框交集面积与并集面积的比值。$$IOU^{A}_{B} = \frac{Area(A \cap B)}{Area(A) + Area(B) - Area(A \cap B)}$$<br></p></blockquote><p>  每个边界框包含<code>5</code>个预测值：<code>x</code>， <code>y</code>，<code>w</code>，<code>h</code>以及<code>置信度</code>。<code>(x, y)</code>坐标表示边界框的中心<strong>相对于网格单元边界的相对位置</strong>，其数值是归一化的结果。比如：</p><p><img src="/img/in_posts/YOLO/YOLO_v1/image-1.png" alt=""></p><p>  <strong>宽度</strong><code>w</code>和<strong>高度</strong><code>h</code>是<u>相对于整个图像的预测值</u>。也就是说，<strong>一个网格单元预测的边界框的中心必须落在该网格单元内，但此边界框的大小范围可以超出此网格单元，其范围大小是相对于整张图像而言的</strong>，其数值也是归一化的结果。</p><p><img src="/img/in_posts/YOLO/YOLO_v1/image-2.png" alt=""></p><p>  <strong>置信度</strong>表示边界框与任何真实值框之间的<code>IOU</code>（交并比）。<br></p><p>  每个网格单元还预测 <code>C</code>个<strong>条件类别概率</strong>，$Pr(Class_i | Object)$ 。这些概率是基于网格单元包含一个物体的条件，即条件概率。<u>无论网格单元中的边界框数量 <code>B</code> 有多少，都只预测一组类别概率</u>。<br></p><p>  测试时，将条件类别概率与各个边界框的置信度预测相乘，</p><p>$$\begin{aligned}Pr(Class_i | Object) * Pr(Object) * IOU_{pred}^{truth} \\ = Pr(Class_i) * IOU_{pred}^{truth} \\ ······（1） \end{aligned}$$</p><p>可得每个框的<strong>针对类别的置信度分数</strong>。这些分数既编码了该类别出现在框中的概率，也编码了边界框与对象的拟合程度。</p><blockquote><p>这里说明，模型不仅给出了每个边界框内包含对象的置信度，而且给出了这个边界框内对象属于特定类别的置信度</p></blockquote><p><img src="/img/in_posts/YOLO/YOLO_v1/image.png" alt=""></p><p>  <code>YOLO</code> 将检测建模为一个回归问题。它将图像划分为 $S \times S$ 的网格，并为每个网格单元预测 $B$ 个边界框、这些边界框的置信度以及 $C$ 个类别概率。这些预测被编码为一个 $S \times S \times (B * 5 + C)$ 的<strong>张量</strong>。</p><br><h4 id="网络设计-⌊Network-Design⌉">网络设计 ⌊Network Design⌉</h4><p>  <code>YOLO</code>模型被实现为<strong>卷积神经网络</strong>，网络的初始卷积层从图像中提取特征，而在<strong>全连接层</strong>预测输出概率和坐标。受到用于图像分类的<code>GoogLeNet</code>模型的启发，<code>YOLO</code> 网络结构包含<code>24</code>个卷积层，随后是<code>2</code>个全连接层。与 <code>GoogLeNet</code> 模型使用的 <code>inception</code> 模块不同的是，<code>YOLO</code>在 <code>3x3</code> 的卷积层后使用<code>1x1</code>的降维层。直接看结构图：</p><p><img src="/img/in_posts/YOLO/YOLO_v1/image-3.png" alt="模型结构图"></p><p>输入图像大小为 <code>448x448</code>，经过 <code>24</code> 个卷积层和若干池化层后输出为 <code>7x7x1024</code>张量（倒数第三个立方体），最后再经过两层全连接层，得到网络的最终输出，即预测的 <code>7x7x30</code>张量。根据前面的内容，预测的结果是 $S \times S \times (B * 5 + C)$，这里的 <code>7x7x30</code> 含义是:</p><ul><li><code>448x448</code>的图像被划分为<code>7x7</code> 的网络；</li><li>论文中，<code>B</code>取值可以调整，这里取 <code>B = 2</code>，即每个网格单元预测 <code>2</code> 个边界框。而类别概率数量 <code>C</code> 取值为 <code>20</code>。于是最终得到 <code>(2 * 5 + 20) = 30</code>。</li></ul><p><img src="/img/in_posts/YOLO/YOLO_v1/image-4.png" alt=""></p><p>对于整个结构，由多个卷积层和池化层组成，以提取图像的特征。初始的卷积层使用<code>7x7</code>的卷积核，步长为<code>2</code>，这会将输入图像的特征图尺寸减半，同时增加深度。随后，网络中<strong>交替使用</strong><code>3x3</code>卷积层和<code>1x1</code>卷积层，其中<code>3x3</code>卷积层用于捕捉局部特征，而<code>1x1</code>卷积层则用于<u>降低特征图的通道数，减少参数数量，并在特征融合中引入非线性</u>。此外，网络中还包含最大池化层，用于降低特征图的空间维度，增加感受野，并提供平移不变性。最终，经过一系列卷积和池化操作后，特征图被展平并通过全连接层，输出最终的预测结果，包括边界框的位置、尺寸和类别概率。在最后一个卷积层，它输出一个形状为 <code>(7, 7, 1024)</code> 的张量，然后张量展开。使用<code>2</code>个全连接层作为一种线性回归的形式，它输出<code>1470</code>个参数，然后<code>reshape</code>为 <code>(7, 7, 30)</code>。</p><blockquote><p>除了<code>YOLO</code>外，作者还训练了一个快速版本的<code>YOLO</code>，旨在突破快速目标检测的界限。<code>Fast YOLO</code>使用了一个具有较少卷积层（<code>9</code>层而不是<code>24</code>层）和较少滤波器的神经网络。除了网络的大小外，<code>YOLO</code>和<code>Fast YOLO</code>的所有训练和测试参数都相同。</p></blockquote><h3 id="训练-⌊Training⌉">训练 ⌊Training⌉</h3><p>  <code>YOLO</code>模型首先在<code>ImageNet</code>的<code>1000</code>类分类数据集上进行预训练，使用前<code>20</code>个卷积层以及平均池化层和全连接层，达到<code>88%</code>的<code>top-5</code>准确率。</p><p>  为了进行目标检测，模型增加了<code>四个卷积层</code>和<code>两个全连接层</code>，并将输入分辨率从<code>224x224</code>提升至<code>448x448</code>以捕捉更精细的视觉信息。</p><p>  模型的输出层预测归一化的边界框坐标和类别概率，其中边界框的宽高和图像宽高成比例，坐标则是相对于网格单元的偏移量。和前面的描述保持一致。</p><p>  除了对网络结构的最后一层使用线性激活函数外，其他所有层使用了下面的 <code>Leaky ReLU</code> 函数：</p><p>$$\phi(x) = \begin{cases} x,\ if\ x &gt;\ 0 \\<br>0.1x,\ otherwise \end{cases} ······（2） $$</p><p>  论文中优化了模型输出中的平方和误差:</p><h4 id="平方和误差的局限性">平方和误差的局限性</h4><ol><li>将定位误差和分类误差同等对待<br>在目标检测中，<strong>定位误差</strong>直接影响到预测框与真实物体的交并比 <code>IOU</code>。而<strong>分类误差</strong>对检测性能的影响相对较小，分类误差主要影响的是识别物体类别的准确性，但在有些情况下，即使分类错误或导致检测结果不正确，只要检测的位置和大小足够正确，检测的结果也可以被接受；</li><li>将大框和小框的误差同等对待<br>世界上，小框对误差更加敏感，因为小框的交并比（<code>IOU</code>）对定位精度要求更高。</li></ol><h4 id="优化措施">优化措施</h4><ol><li><p>对于定位误差和分类误差，<code>YOLO</code> 在损失函数中引入了两个参数：$\lambda_{coord}$ 和 $\lambda_{noobj}$。</p><ul><li>$\lambda_{coord}$ 用于<u>增加边界框坐标预测的权重</u>；</li><li>$\lambda_{noobj}$ 用于<u>减少不包含物体的网格单元的置信度预测的权重</u>。</li><li>论文中设置 $\lambda_{coord} = 5$ 和 $\lambda_{noobj} = 0.5$，使模型更加关注边界框的精准定位，并减少了对不包含物体的网格单元的置信度预测惩罚。</li></ul></li><li><p>对于大框和小框对误差的敏感性不同，<code>YOLO</code> 在损失函数中使用的是高度和宽带的平方根，而不是直接使用高度和宽度。比如，对于宽度 <code>w</code>：<br><img src="/img/in_posts/YOLO/YOLO_v1/image-5.png" alt=""><br><br>可以看到，对于同等误差 $\Delta w$，小框较大框更加敏感，很好地契合了优化目的。</p></li></ol><br><p>  于是，通过前面的优化，<code>YOLO</code> 使用了如下的，多部分和的损失函数：</p><p>$$\begin{aligned} \lambda_{coord} \sum_{i=1}^{S^2} \sum_{j=1}^{B}\ \mathbf{1}<em>{ij}^{obj}[(x_i-\hat{x_i})^2 + (y_i - \hat{y_i})^2] \\ + \lambda</em>{coord} \sum_{i=1}^{S^2} \sum_{j=1}^{B}\ \mathbf{1}<em>{ij}^{obj}[(\sqrt{w_i}-\sqrt{\hat{w_i}})^2 + (\sqrt{h_i}-\sqrt{\hat{h_i}}\ )^2] \\ + \sum</em>{i=1}^{S^2} \sum_{j=1}^{B}\ \mathbf{1}<em>{ij}^{obj} (C_i - \hat{C_i})^2 \\ + \lambda</em>{noobj} \sum_{i=1}^{S^2} \sum_{j=1}^{B} \mathbf{1}<em>{ij}^{noobj} (C_i - \hat{C_i})^2 \\ + \sum</em>{i=1}^{S^2} \sum_{c \in classes} (p_i© - \hat{p_i}©)^2 \\ ······（3）\end{aligned}$$</p><blockquote><p>论文中这里貌似出现了笔误，论文中的损失函数中求和是从 <code>i=0</code> 到 <code>S^2</code>，即 $\sum_{i = 0}^{S^2}$，实际上应该为$\sum_{i = 1}^{S^2}$ 或者 $\sum_{i = 0}^{S^2 - 1}$。</p></blockquote><p>损失函数中的 $\mathbf{1}$ 符号是一个指示函数，其中：</p><ul><li><p>$\mathbf{1}<em>{i}^{obj}$ 表示第 <code>i</code> 个网格单元是否包含物体，是则 $\mathbf{1}</em>{i}^{obj} = 1$，否则 $\mathbf{1}_{i}^{obj} = 0$，即：</p><p>$$\mathbf{1}_{i}^{obj} = \begin{cases} 1,\ 网格单元包含物体 \\ 0,\ 网格单元不含物体\end{cases}$$</p><p>$\mathbf{1}_{i}^{noobj}$ 恰与之相反：</p><p>$$\mathbf{1}_{i}^{noobj} = \begin{cases} 1,\ 网格单元不含物体 \\ 0,\ 网格单元包含物体\end{cases}$$</p></li><li><p>$\mathbf{1}<em>{ij}^{obj}$ 表示第 <code>i</code> 个网格单元的第 <code>j</code> 个边界框预测器是否负责预测一个物体（一个网格单元会预测 <code>B</code> 个边界框），是则 $\mathbf{1}</em>{ij}^{obj} = 1$，否则 $\mathbf{1}_{ij}^{obj} = 0$，即：</p><p>$$\mathbf{1}_{ij}^{obj} = \begin{cases} 1,\ 第 i 个网格单元的第 j 个边界框预测器是否负责预测一个物体 \\ 0,\ 否则\end{cases}$$</p></li></ul><p>  实际上，上述损失函数可以分为以下几个部分：</p><ol><li><p><strong>位置误差</strong></p><p>$$\begin{aligned}\lambda_{coord} \sum_{i=1}^{S^2} \sum_{j=1}^{B}\ \mathbf{1}<em>{ij}^{obj}[(x_i-\hat{x_i})^2 + (y_i - \hat{y_i})^2] \\ + \lambda</em>{coord} \sum_{i=1}^{S^2} \sum_{j=1}^{B}\ \mathbf{1}_{ij}^{obj}[(\sqrt{w_i}-\sqrt{\hat{w_i}})^2 + (\sqrt{h_i}-\sqrt{\hat{h_i}}\ )^2] \end{aligned}$$</p></li><li><p><strong>置信度误差（含物体时）</strong></p><p>$$\sum_{i=1}^{S^2} \sum_{j=1}^{B}\ \mathbf{1}_{ij}^{obj} (C_i - \hat{C_i})^2 $$</p></li><li><p><strong>置信度误差（不含物体时）</strong></p><p>$$\lambda_{noobj} \sum_{i=1}^{S^2} \sum_{j=1}^{B} \mathbf{1}_{ij}^{noobj} (C_i - \hat{C_i})^2$$</p></li><li><p><strong>分类误差</strong></p><p>$$\sum_{i=1}^{S^2} \sum_{c \in classes} (p_i ( c ) - \hat{p_i} ( c ) )^2$$<br>其中，$p_i ( c )$ 表示第 $i$ 个网格单元中的物体属于类别 $c$ 的真实概率，而 $\hat{p_i} ( c )$ 表示模型预测的类别概率。事实上，损失函数中的 “含帽” 的变量是模型预测的相关值。</p></li></ol><p><img src="/img/in_posts/YOLO/YOLO_v1/image-6.png" alt=""></p><p>  由损失函数不难看出，由于分类误差中含有指示函数 $\mathbf{1}_{i}^{obj}$ ，所以损失函数只会在该网格单元中存在物体时才对分类误差进行惩罚。</p><p>  此外，由于位置误差中指示函数 $\mathbf{1}_{ij}^{obj}$ 的存在，损失函数只会某个某个边界框预测器对真实值框 “负责” 时会惩罚边界框的位置误差。</p><h3 id="YOLO-的局限性">YOLO 的局限性</h3><p>YOLO的局限性主要包括以下几点：</p><ol><li><p><strong>空间约束</strong>：<code>YOLO</code>对边界框预测施加了严格的空间限制，每个网格单元只能预测两个框，并且每个框只能有一个类别。这种设计限制了模型对邻近物体的检测能力，尤其是在物体密集或重叠的情况下，<code>YOLO</code>可能会漏检一些物体；</p></li><li><p><strong>小物体检测困难</strong>：由于每个网格单元的预测能力有限，<code>YOLO</code>在检测成群出现的小物体时表现不佳，例如鸟群或昆虫群等。这些小物体可能因为尺寸小且数量多而难以被准确识别和定位；</p></li><li><p><strong>特征粗糙</strong>：<code>YOLO</code>的网络结构中包含多个下采样层，导致其在预测边界框时使用的特征较为粗糙。这使得模型在处理需要精细特征的物体时（如具有复杂形状或纹理的物体）可能不够准确；</p></li><li><p><strong>损失函数的局限</strong>：<code>YOLO</code>的损失函数在处理小框和大框的误差时没有区别对待，即对小框中的小误差和大框中的小误差赋予相同的权重。然而，在实际检测中，小框中的小误差对交并比（<code>IoU</code>）的影响较大，而大框中的小误差影响较小。这可能导致模型在优化过程中对小物体的定位不够准确；</p></li><li><p><strong>类别泛化能力有限</strong>：虽然<code>YOLO</code>在一定程度上能够泛化到新的领域或数据分布，但其在处理与训练数据分布差异较大的场景时，可能会出现性能下降的情况。这是因为模型的特征学习和类别识别能力在很大程度上依赖于训练数据的多样性和代表性。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>目标检测</category>
      
      <category>YOLO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PaperShare</tag>
      
      <tag>YOLO</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（四）</title>
    <link href="/2024/12/28/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_4/"/>
    <url>/2024/12/28/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_4/</url>
    
    <content type="html"><![CDATA[<h2 id="预定义宏⌊Predefined-Macros⌉">预定义宏⌊Predefined Macros⌉</h2><p>  一些<strong>类对象宏</strong><code>object-like Macros</code>是预定义的，使用它们时不需要提供它们的定义。它们分为三类: <code>标准宏⌊Standard Macros⌉</code>、<code>通用宏⌊Common Macros⌉</code>和<code>系统特定宏⌊System-specific Macros⌉</code>。</p><p>  在 <code>C++</code> 中，还有第四类：<code>命名操作符⌊Named operators⌉</code>。它们就像预定义的宏，但是不能被取消定义（<code>undefine</code>）。</p><h3 id="标准预定义宏⌊Standard-Predefined-Macros⌉">标准预定义宏⌊Standard Predefined Macros⌉</h3><p>  标准的预定义宏是由相关的语言标准指定的，因此它们可用于实现这些标准的所有编译器。旧的编译器可能不会提供所有这些选项。这类预定义宏的名字<u>都以双下划线开头</u>。例如：</p><h4 id="1-FILE-宏">1. __FILE__宏</h4><p>  <code>__FILE__</code>宏以<code>C</code><strong>字符串的名称常量</strong>的形式展开。这是预处理器打开文件的路径，而不是<code>#include</code>中指定的短名称或作为输入的文件名参数。例如，<code>/usr/local/include/myheade.h</code>是<code>__FILE__</code>宏可能的扩展结果。</p><h4 id="2-LINE-宏">2. __LINE__宏</h4><p>  <code>__LINE__</code>宏将以<strong>十进制整数常数</strong>的形式扩展到当前的输入行数。虽然我们称之为预定义的宏，但它是一个相当奇怪的宏，因为它的“定义”会随着每一个新的源代码行而变化。</p><br><p>  <code>__FILE__</code> 和 <code>__LINE__</code> 对于生成消息来报告程序检测到的错误非常有用; 消息可以报告检测到错误的源代码的行数。比如说：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">fprintf</span> (stderr, <span class="hljs-string">&quot;Internal error: &quot;</span><br>               <span class="hljs-string">&quot;negative string length &quot;</span><br>               <span class="hljs-string">&quot;%d at %s, line %d.&quot;</span>,<br>       length, __FILE__, __LINE__);<br></code></pre></td></tr></table></figure><p>  对于 <code>__FILE__</code> 和 <code>__LINE__</code> 宏遇到 <code>#include</code> 预处理指令时其展开会有变化。当编译器遇到 <code>#include</code> 指令时，它会将当前的输入流替换为被包含文件的内容。在这个过程中，预处理器会改变 <code>__FILE__</code> 和 <code>__LINE__</code> 宏的展开值，使它们分别对应于被包含文件的名称和行号。也即是说：</p><ul><li><code>__FILE__</code> 宏会展开为被包含文件的文件名字符串；</li><li><code>__LINE__</code> 宏会展开为被包含文件对应位置的行号。</li></ul><p>  当包含文件结束，即 <code>#include</code> 指令结束，编译器回到包含 <code>#include</code> 指令的原文件继续处理，<code>__FILE__</code> 和 <code>__LINE__</code> 的值会恢复到 <code>#include</code> 指令之前的值。但是需要注意的是，<code>__LINE__</code> 的值会增加 <code>1</code>，因为<code>#include</code> 指令已经执行完成，当前是 <code>#include</code> 指令的下一行。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;header.h&quot;</span></span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Back in main.cpp, line: &quot;</span> &lt;&lt; __LINE__ &lt;&lt; std::endl;   <span class="hljs-comment">// 此处 __LINE__ 值为 3</span><br><br><span class="hljs-comment">// header.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_INFO() std::cout \</span><br><span class="hljs-meta">    &lt;&lt; <span class="hljs-string">&quot;In header.h, file: &quot;</span>   \</span><br><span class="hljs-meta">    &lt;&lt; __FILE__ &lt;&lt; <span class="hljs-string">&quot;, line: &quot;</span>  \</span><br><span class="hljs-meta">    &lt;&lt; __LINE__ &lt;&lt; std::endl</span><br><br><span class="hljs-built_in">PRINT_INFO</span>();<br></code></pre></td></tr></table></figure><p>  当 <code>__LINE__</code> 和 <code>__FILE__</code> 遇到 <code>#line</code> 指令时同样有所变化，这里不做讨论。</p><blockquote><p>  <code>C99</code>引入了 <code>__func__</code>,<code>GCC</code>长期以来一直提供 <code>__FUNCION__</code>。这两个字符串都包含当前函数的名称(两者在语义上略有不同; 请参阅 <code>GCC</code> 手册)。它们<strong>都不是宏</strong>; 预处理器不知道当前函数的名称。但是，它们往往与 <code>__FILE__</code> 和 <code>__LINE__</code> 结合使用。</p></blockquote><h4 id="3-DATE-宏">3. __DATE__宏</h4><p>  此宏将扩展为描述预处理器运行日期的<strong>字符串常量</strong>。字符串常量包含<code>11</code>个字符，看起来像<code>Feb 12 1996</code>。如果一个月的日期小于<code>10</code>，则在左边用一个空格填充。</p><p>  如果<code>GCC</code>不能确定当前的日期，它将发出一个警告消息（每次编译一次），而<code>__DATE__</code>将扩展到 <code>??? ?? ????</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">__DATE__<br><br><span class="hljs-comment">// 预处理之后</span><br><span class="hljs-string">&quot;Jan  9 2025&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-TIME-宏">3. __TIME___宏</h4><p>  此宏扩展为一个描述预处理器运行时间的字符串常量。字符串常量包含<code>8</code>个字符，看起来像<code>23:59:01</code>。</p><p>  如果<code>GCC</code>不能确定当前的时间，它将发出一个警告消息（每次编译一次），而<code>__TIME__</code>将扩展到 <code>??:??:??</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">__TIME__<br><br><span class="hljs-comment">// 预处理之后</span><br><span class="hljs-string">&quot;23:14:14&quot;</span><br></code></pre></td></tr></table></figure><h3 id="通用预定义宏⌊Common-Predefined-Macros⌉">通用预定义宏⌊Common Predefined Macros⌉</h3><p>  这里不作讨论；</p><h3 id="系统特定预定义宏⌊System-specific-Predefined-Macros⌉">系统特定预定义宏⌊System-specific Predefined Macros⌉</h3><p>  这里不作讨论；</p><h3 id="命名运算符⌊C-Named-Operators⌉">命名运算符⌊C++ Named Operators⌉</h3><p>  在 <code>C++</code> 中，有 <code>11</code> 个关键字是通常使用标点符号书写的运算符的交替拼写。 即使在预处理器中，这些关键字也是如此处理的。 它们在 <code>#if</code> 中起着操作符的作用，不能被定义为宏。如下：</p><table><thead><tr><th>Named Operator</th><th>Punctuator</th></tr></thead><tbody><tr><td>and</td><td>&amp;&amp;</td></tr><tr><td>and_eq</td><td>&amp;=</td></tr><tr><td>bitand</td><td>&amp;</td></tr><tr><td>bitor</td><td>|</td></tr><tr><td>compl</td><td>~</td></tr><tr><td>not</td><td>!</td></tr><tr><td>not_eq</td><td>!=</td></tr><tr><td>or</td><td>||</td></tr><tr><td>or_eq</td><td>|=</td></tr><tr><td>xor</td><td>^</td></tr><tr><td>xor_eq</td><td>^=</td></tr></tbody></table><h2 id="取消定义或重新定义宏">取消定义或重新定义宏</h2><p>  如果一个宏不再有用，可以使用 <code>#undef</code> 指令将其取消定义。<code> #undef</code> 指令<strong>只有一个参数</strong>，即要解除定义的宏的名称。 <strong>即使宏是函数式的，也要使用裸宏名</strong>。 如果在宏名后面出现任何内容，都是错误的。 如果名称不是宏，<code>#undef</code> 不起作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO 4</span><br>x = FOO;        <span class="hljs-comment">// x = 4;</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> FOO</span><br>x = FOO;        <span class="hljs-comment">// x = FOO;</span><br></code></pre></td></tr></table></figure><p>  如果某个宏被<strong>取消定义</strong>了，该标识符可通过随后的 <code>#define</code> 指令重新定义为宏。 新定义不必与旧定义有任何相似之处。但是，如果一个标识符本身是宏，然后又通过 <code>#define</code> 指令进行重新定义，那么新的定义需要和旧定义<strong>在效果上是相同的</strong>。什么是在效果上相同？如下：</p><ul><li>两者需要保持是同一类宏（类对象宏或类函数宏）；</li><li>替换列表中的所有标记都是一样的；</li><li>如果宏定义中有参数，那么这些参数也必须相同；</li><li>空白出现在两者相同的位置。但空白的数量不必完全相同。注意，注释也算空白。<blockquote><p>空白字符（包括空格、制表符、换行符等）在两个宏定义中出现在相同的地方。这里的“相同的地方”指的是空白字符的位置，而不是空白字符的数量。也就是说，两个宏定义在结构上看起来应该是相似的，尽管它们之间的空白字符数量可能不同。此外，注释（comments）也被视为空白字符。</p></blockquote></li></ul><p>  例如下面的定义在效果上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOUR (2 + 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOUR         (2    +    2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOUR (2 <span class="hljs-comment">/* two */</span> + 2)</span><br></code></pre></td></tr></table></figure><p>而下面的定义在效果上是不相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOUR (2 + 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOUR ( 2+2 )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOUR (2 * 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOUR(score,and,seven,years,ago) (2 + 2)</span><br></code></pre></td></tr></table></figure><p>  你可能会问，既然前后两者在效果上是相同的，那么这样做的意义在哪里？实际上，对宏的重定义尽管要求保持原有的效果不变，但是可以增加其他的功能，比如打印日志等，如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 假设有一个宏 MAX，用于比较两个值并返回较大的一个</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span><br><br><span class="hljs-comment">// 现在需要在其中添加一些日志记录用于调试</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) (&#123; \</span><br><span class="hljs-meta">    int _max = ((a) &gt; (b) ? (a) : (b)); \</span><br><span class="hljs-meta">    printf(<span class="hljs-string">&quot;MAX(%d, %d) = %d\n&quot;</span>, a, b, _max); \</span><br><span class="hljs-meta">    _max; \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><blockquote><p>在这个重新定义的宏中，使用了 <code>GCC</code> 的扩展特性，即在宏中使用 <code>&#123;&#125;</code> 来创建一个复合语句，这允许在宏中使用局部变量和多条语句。添加了一个局部变量 <code>_max</code> 来存储比较的结果，并通过 <code>printf</code> 函数输出比较的值和结果，这有助于调试。最后，返回 <code>_max</code>，确保宏的返回值与原始定义相同。</p></blockquote><p>  <strong>如果重新定义的宏定义实际上与旧定义不一致</strong>，预处理器会发出警告，<strong>并更改宏以使用新定义</strong>。如果新定义实际上与旧定义相同，则重新定义将被默默忽略。例如，这就允许两个不同的头定义一个共同的宏。只有当定义不匹配时，预处理器才会抱怨。</p><h2 id="宏参数中的指令">宏参数中的指令</h2><p>  有时，在宏的参数中使用预处理器指令也很方便。<code>C</code> 和 <code>C++</code> 标准声明这些情况下的<strong>行为是未定义的</strong>。 <code>GNU CPP</code> 处理宏参数中任意指令的方式，与不存在函数式宏调用时处理指令的方式完全相同。</p><p>  如果在一个宏调用中，该宏被重新定义，那么新定义在参数预扩展时生效，但原定义仍用于参数替换。 下面是一个病态的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> f(x) x x</span><br><span class="hljs-built_in">f</span> (<span class="hljs-number">1</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> f 2</span><br>f)<br></code></pre></td></tr></table></figure><p>最终会被拓展为：<code>1 2 1 2</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
      <category>Macros</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>C</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程之层次锁</title>
    <link href="/2024/12/26/Concurrency/c++%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B1%82%E6%AC%A1%E9%94%81/"/>
    <url>/2024/12/26/Concurrency/c++%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B1%82%E6%AC%A1%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="层次锁⌊hierarchical-lock⌉">层次锁⌊hierarchical lock⌉</h2><p>  在<code>C++</code>多线程编程中，避免死锁是一大要务。简单回顾一下死锁的概念：</p><h3 id="死锁">死锁</h3><p>  死锁（<code>Deadlock</code>）多线程执行过程中，每个线程都持有一些资源，同时又尝试获取其他线程所持有的资源，导致所有线程都无法继续执行的一种状态。简单理解，就是多个线程相互等待对方释放资源，但没有任何线程能够继续向前推进。</p><p>  死锁通常涉及四个基本条件：</p><ol><li><p><strong>互斥</strong><br>指资源在某一时刻只能被一个线程使用，如多线程编程中常见的互斥元 <code>mutex</code>；</p></li><li><p><strong>占有和等待</strong><br>指一个线程至少占有一个资源，同时又等待获取其他线程占有的资源；</p></li><li><p><strong>不可抢占</strong><br>指资源只能由占有它的线程资源释放，而不能强行剥夺；</p></li><li><p><strong>循环等待</strong><br>指存在一个线程的集合，其中每个线程都在等待下一个线程所占有的资源，形成一个等待的循环。</p></li></ol><h3 id="避免死锁">避免死锁</h3><p>  避免死锁的方法有很多，基本思路就是破坏死锁发生的四个基本条件：</p><ol><li><p><strong>破坏互斥条件</strong><br>即允许资源同时被多个线程访问，但这通常并不适合需要互斥访问的资源；</p></li><li><p><strong>破坏占有与等待条件</strong><br>要求线程在请求新资源之前释放所有已占有的资源；</p></li><li><p><strong>破坏不可抢占条件</strong><br>允许资源被抢占，在实践中这很难实现；</p></li><li><p><strong>破坏循环等待条件</strong><br>通过给所有资源（如互斥元）编号一个顺序，并要求线程按照这个顺序请求资源；</p></li></ol><p>  我们这里讨论破坏循环等待条件的情况，即为所有资源编号一个顺序，使得所有线程只能按照固定的顺序请求资源。下面的“资源”统一以互斥元（<code>mutex</code>）为例。</p><h4 id="以固定顺序获取锁">以固定顺序获取锁</h4><p>  相当直观的一个事实：当死锁发生时，必须存在一个线程之间的等待循环，每个线程都在等待下一个线程释放资源。如果存在两个或者更多的互斥元，<code>C++17</code> 引入了 <code>std::lock</code> 的方法来<strong>原子性</strong>地锁定多个互斥元，也即是说<u>要么同时锁定多个互斥元，要么阻塞当前线程直到所有的互斥元都可用</u>。这是可以考虑地一种方法，但是当不能使用 <code>std::lock</code> 的单个操作取得多个锁时，次优的做法就是在每个线程中以相同的顺序获取互斥元，也就是破坏循环等待条件。</p><p>  很好理解的是，这里的<code>顺序</code>是一种全局的顺序，而非相对的。什么意思，比如，一个函数的参数列表中传入两个互斥元，我们以一种相对的顺序：先锁第一个参数，再锁第二个参数，此时就是一种相对的而非全局的顺序。很显然，这样的相对锁定顺序同样会引起死锁的发生——当线程 <code>A</code> 和线程 <code>B</code> 的参数顺序恰好相反时，这就是一个典型的死锁。</p><p>  如何实现一种全局的顺序呢？下面介绍的<strong>层次锁</strong>将是一个不错的方法。</p><h3 id="使用层次锁">使用层次锁</h3><p>  你可以称之为 <code>层次锁⌊hierarchical lock⌉</code>、<code>层次互斥元⌊hierarchical_mutex⌉</code>（<code>hierarchical adj 分等级的</code>） 等等，一切都是接受的，这并非关键。<strong>层次锁</strong>并未在 <code>C++</code> 标准中得到实现，而是一种用户自定义的互斥锁，这很有用，兴许不久的将来会看到它会进入到 <code>C++</code> 标准中。层次锁实际上是定义了互斥元的锁定顺序的特例，并在实际运行中检查是否遵循这种<code>顺序</code>。</p><p>  <code>hierarchical_mutex</code> 的工作原理基于一个简单的规则：在同一线程中，只能按照层次值递减的顺序锁定多个 <code>hierarchical_mutex</code>。这实际上就体现了锁定的固定顺序：即从<u>高到低的顺序</u>。如果尝试违反这一规则的顺序锁定互斥元，<code>hierarchical_mutex</code> 会抛出异常，表明层次被违反。这里需要注意的是：如果锁在层次中处于相同级别，则不能同时持有它们。</p><blockquote><p>那么实现细节？</p></blockquote><p>  一个自定义的 <code>hierarchical_mutex</code> 类通常包含以下几个部分：</p><ol><li>一个内部的 <code>std::mutex</code> 用于实际的互斥；</li><li>一个 <code>hierarchical_value</code> 用于存储该互斥锁的层次值；</li><li>一个 <code>previous_hierarchy_value</code> 用于存储当前线程的前一个层次值；</li><li>一个 <code>this_thread_hierarchy_value</code> 的静态局部变量，用于跟踪当前线程的层次值。</li></ol><p>  当然，为了支持 <code>std::lock_guard</code> 的 <code>RAII</code> 惯用语法，<code>hierarchical_mutex</code> 类提供了 <code>lock</code>、<code>unlock</code> 和 <code>try_lock</code> 等成员函数，以支持互斥锁的基本操作，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(hierarchical_mutex(<span class="hljs-number">5000</span> <span class="hljs-comment">/*层次值*/</span>))</span></span><br></code></pre></td></tr></table></figure><blockquote><p><code>try_lock()</code> 成员函数用于尝试锁定一个互斥元，若互斥元的锁已经为另一个线程所持有，则返回 <code>false</code></p></blockquote><p>下面是 <code>hierarchical_mutex</code> 的简单实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">hierarchical_mutex</span>&#123;<br>    std::mutex internal_mutex;  <span class="hljs-comment">// 用于实际的互斥</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">const</span> hierarchy_value;    <span class="hljs-comment">// 存储该互斥锁的层次值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> previous_hierarchy_value;   <span class="hljs-comment">// 存储当前线程的前一个层次值</span><br>                                              <span class="hljs-comment">// 互斥元解锁时恢复层次值</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> this_thread_hierarchy_value;  <br>            <span class="hljs-comment">// thread_local 用于声明一个局部于线程的静态变量，这意味着每个线程都会拥有该</span><br>            <span class="hljs-comment">// 变量的独立副本。这类变量称为线程局部存储（Thread-Local Storge, TLS）</span><br>            <span class="hljs-comment">// 生命周期是始于线程创建，终于线程结束</span><br><br>            <span class="hljs-comment">// this_thread_hierarchy_value 用于跟踪当前线程的层次值</span><br><br>    <span class="hljs-comment">// 规则检查</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_for_hierarchy_violation</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 锁定顺序应该是由高到低，当前线程只能锁定层次值低于自身的互斥元</span><br>        <span class="hljs-keyword">if</span> (this_thread_hierarchy_value &lt;= hierarchy_value)&#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;mutex hierarchy violated&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新层次值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_hierarchy_value</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 保存当前线程层次值到 previous_hierarchy_value</span><br>        previous_hierarchy_value = this_thread_hierarchy_value;<br><br>        <span class="hljs-comment">// 锁定一个互斥元后将线程的层次值更新为互斥元对应的层次值</span><br>        this_thread_hierarchy_value = hierarchy_value;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，接受一个 unsigned long 类型的层次值</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">hierarchical_mutex</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> value)</span>: hierarchy_value(value),</span><br><span class="hljs-function">            previous_hierarchy_value(<span class="hljs-number">0</span>) &#123;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">check_for_hierarchy_violation</span>();<br>        internal_mutex.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-built_in">update_hierarchy_value</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 恢复当前线程的层次值为 previous_hierarchy_value</span><br>        this_thread_hierarchy_value = previous_hierarchy_value;<br>        internal_mutex.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">check_for_hierarchy_violation</span>();<br>        <span class="hljs-keyword">if</span> (!internal_mutex.<span class="hljs-built_in">try_lock</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">update_hierarchy_value</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// this_thread_hierarchy_value 设置为 ULONG_MAX，即初始化为最大值，目的就是使其初始时可</span><br><span class="hljs-comment">// 以锁定任何层次值的互斥元，选取哪一层次的锁作为开始总是自由的</span><br><span class="hljs-function"><span class="hljs-keyword">thread_local</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> </span><br><span class="hljs-function">    <span class="hljs-title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="hljs-params">(ULONG_MAX)</span></span>;<br></code></pre></td></tr></table></figure><p>  下面以一个实际例子来讲解 <code>hierarchical_mutex</code> 的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">hierarchical_mutex <span class="hljs-title">high_level_mutex</span><span class="hljs-params">(<span class="hljs-number">10000</span>)</span></span>; <span class="hljs-comment">// 定义一个高层次值的层次互斥元</span><br><span class="hljs-function">hierarchical_mutex <span class="hljs-title">low_level_mutex</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>;   <span class="hljs-comment">// 定义一个低层次值的层次互斥元</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">do_low_level_stuff</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">low_level_func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(low_level_mutex)</span></span>; <span class="hljs-comment">// RAII 语法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">do_low_level_stuff</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">high_level_stuff</span><span class="hljs-params">(<span class="hljs-type">int</span> some_param)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">high_level_func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(high_level_mutex)</span></span>;<br>    <span class="hljs-built_in">high_level_stuff</span>(<span class="hljs-built_in">low_level_func</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_a</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">high_level_func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是整个代码函数依赖图：</p><pre><code class=" mermaid">graph TD    threadA[&quot;thread_a()&quot;]    highLevelFunc[&quot;high_level_func()&quot;]    lowLevelFunc[&quot;low_level_func()&quot;]    doLowLevelStuff[&quot;do_low_level_stuff()&quot;]    highLevelStuff[&quot;high_level_stuff()&quot;]    threadA --&gt; highLevelFunc    highLevelFunc --&gt; lowLevelFunc    highLevelFunc --&gt; highLevelStuff    lowLevelFunc --&gt; doLowLevelStuff</code></pre><p>  假设线程<code>a</code> 执行 <code>thread_a</code> 函数，初始时，线程 <code>a</code> 的<code>this_thread_hierarchy_value</code> 为 <code>ULONG_MAX</code>，即最大值。之后，<code>thread_a()</code> 调用 <code>high_level_func()</code>，并锁定了 <code>high_level_mutex</code>（具有层次值为 <code>10000</code>），使得线程 <code>a</code> 的 <code>this_thread_hierarchy_value</code> 值更新为当前层次互斥元的层次值 <code>10000</code>。然后在 <code>high_level_func()</code> 中调用了 <code>low_level_func()</code>，并锁定了 <code>low_level_mutex</code>（具有层次值为 <code>5000</code>），此时线程 <code>a</code> 的 <code>this_thread_hierarchy_value</code> 值更新为当前层次互斥元的层次值 <code>5000</code>。所有，线程 <code>a</code> 对层次互斥元的锁定符合由高到低的顺序，因此运行良好。</p><p>  来看运行失败的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">hierarchical_mutex <span class="hljs-title">other_mutex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_other_stuff</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">other_stuff</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">high_level_func</span>();<br>    <span class="hljs-built_in">do_other_stuff</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_b</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(other_mutex)</span></span>;<br>    <span class="hljs-built_in">other_stuff</span>();<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TD    threadB[&quot;thread_b()&quot;]    otherStuff[&quot;other_stuff()&quot;]    highLevelFunc[&quot;high_level_func()&quot;]    lowLevelFunc[&quot;low_level_func()&quot;]    doLowLevelStuff[&quot;do_low_level_stuff()&quot;]    highLevelStuff[&quot;high_level_stuff()&quot;]    doOtherStuff[&quot;do_other_stuff()&quot;]    threadB --&gt; otherStuff    otherStuff --&gt; highLevelFunc    otherStuff --&gt; doOtherStuff    highLevelFunc --&gt; lowLevelFunc    highLevelFunc --&gt; highLevelStuff    lowLevelFunc --&gt; doLowLevelStuff</code></pre><p>  线程 <code>b</code> 执行 <code>thread_b</code> 函数，初始时，线程 <code>b</code> 的<code>this_thread_hierarchy_value</code> 同样为 <code>ULONG_MAX</code>，即最大值。之后，<code>thread_b()</code> 经过了 <code>check_for_hierarchy_violation()</code> 的检查并锁定了 <code>other_mutex</code>（层次值为 <code>100</code>），使得线程 <code>b</code> 的 <code>this_thread_hierarchy_value</code> 值更新为当前层次互斥元的层次值 <code>100</code>。之后 <code>thread_b()</code> 又调用了 <code>other_stuff()</code>，其内部调用了 <code>high_level_func()</code>,而 <code>high_level_func()</code> 尝试锁定具有更高层次值的 <code>high_level_mutex</code>（层次值为 <code>10000</code>），在进行 <code>check_for_hierarchy_violation()</code> 抛出了异常，线程 <code>b</code> 运行失败。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
      <category>Concurrency</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Concurrency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（三）</title>
    <link href="/2024/12/24/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_3/"/>
    <url>/2024/12/24/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_3/</url>
    
    <content type="html"><![CDATA[<h2 id="连接-Concatenation">连接[Concatenation]</h2><p>  在拓展宏时，将两个标记合并成一个标记通常很有用。而这个过程被称为<strong>标记连接</strong> <code>token concatenation</code>（或称<strong>标记粘贴</strong> <code>token pasting</code>），这是通过 <code>##</code>预处理运算符实现的。宏进行展开时，在<code>##</code>运算符两侧的标记会被合并成为一个标记，而<code>##</code>运算符本身会被删去。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE(x, y) x ## y</span><br><br><span class="hljs-built_in">PASTE</span>(My, Class)<br><br><span class="hljs-comment">// 预处理之后</span><br>MyClass<br></code></pre></td></tr></table></figure><h3 id="合法的标记">合法的标记</h3><p>  那么 <code>##</code> 两侧可以放置的合法的标记有哪些呢？一下是一些合法的标记：</p><ol><li>标识符（<code>Identifiers</code>）：合法的 <code>C/C++</code> 标识符，例如变量名、函数名等；</li><li>预处理数字（<code>Preprocessing Numbers</code>）：预处理器识别的数字，包括整数和浮点数；</li><li>字符串字面量（<code>String Literals</code>）：用双引号括起来的字符串；</li><li>宏参数（<code>Macro Parameters</code>）：宏定义中使用的参数；</li><li>宏（<code>Macros</code>）：已经定义过的宏；</li><li>关键字（<code>Keywords</code>）：<code>C\C++</code> 中的关键字，比如 <code>int</code>、<code>if</code>等；</li><li>操作符和分隔符（<code>Operators and Separators</code>）：如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>等；</li><li>空标记（<code>Empty Tokens</code>）：在某些情况下，空标记也是合法的，例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCAT(a, b) a ## b</span><br><span class="hljs-built_in">CONCAT</span>(, foo)<br><br><span class="hljs-comment">// 预处理展开后：</span><br>foo<br></code></pre></td></tr></table></figure></li><li>多字符操作符（<code>Multi-Character Operators</code>）：例如 <code>+=</code>、<code>-&gt;</code> 等；</li></ol><blockquote><p>并非所有的标记都可以使用 <code>##</code> 操作符进行连接。如果两个标记连接后不能形成一个有效的标记，那么预处理器将不会尝试将它们合并，而是会发出警告，并输出这两个标记。这里的有效的标记就是上面罗列的合法的标记。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCAT(a, b) a ## b</span><br><span class="hljs-built_in">CONCAT</span>(x, +)<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">// g++ -E -o main.i main.cpp<br>main.cpp:3:8: error: pasting &quot;x&quot; and &quot;+&quot; does not give a valid preprocessing token<br>   3 | CONCAT(x, +)<br>     |        ^<br>main.cpp:1:22: note: in definition of macro &#x27;CONCAT&#x27;<br>   1 | #define CONCAT(a, b) a ## b<br>     |                      ^<br></code></pre></td></tr></table></figure><p>可以看到，报错信息已经很显然了</p></blockquote><p>  需要注意的是，</p><ul><li><p>注释会转换为空白<br>在宏处理之前，预处理器会将注释转换为空白字符。这就意味着不能通过连接 <code>/</code> 和 <code>*</code> 来创建一个注释，注释在预处理阶段就会被移除；</p></li><li><p><code>##</code> 周围的空白<br>实际上可以在 <code>##</code> 操作符和其操作数之间放置任意数量的空白字符，包括空格、制表符和换行符等，这类空白字符在预处理时都会被忽略；</p></li><li><p><code>##</code> 操作数和注释<br>可以在将要被连接的参数中放置注释，因为注释会被转换为空白字符，所以最终会被 <code>##</code> 处理时忽略；</p></li><li><p><code>##</code> 操作数的位置错误<br><code>##</code> 操作数不能出现在宏体的开头或者结尾：也就是说，<code>##</code> 操作数的两侧必须有标记，当然传入宏参数时可以传入空白标记。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE(a, b) a ## b</span><br><br><span class="hljs-comment">// 正确使用，参数之间有注释</span><br><span class="hljs-built_in">PASTE</span>(a <span class="hljs-comment">/* comment */</span> , b)  <span class="hljs-comment">// 展开为 ab</span><br><br><span class="hljs-comment">// 错误使用，## 出现在宏的开始</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVALID_MACRO1 ##a  <span class="hljs-comment">// 错误，## 没有操作数</span></span><br><br><span class="hljs-comment">// 错误使用，## 出现在宏的结束</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INVALID_MACRO2 a##  <span class="hljs-comment">// 错误，## 没有操作数</span></span><br></code></pre></td></tr></table></figure><h3 id="实际的例子">实际的例子</h3><p>  下面是一个运用宏连接使得代码更简洁的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span>&#123;<br>    <span class="hljs-type">char</span>* name;<br>    <span class="hljs-built_in">void</span> (*function) (<span class="hljs-type">void</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span> commands[] = &#123;<br>    &#123;<span class="hljs-string">&quot;quit&quot;</span>, quit_command&#125;,<br>    &#123;<span class="hljs-string">&quot;help&quot;</span>, help_command&#125;,<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>使用宏连接后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMAND(NAME) &#123;#NAME, NAME ## _command&#125;</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">command</span> commands[] = &#123;<br>    <span class="hljs-built_in">COMMAND</span>(quit),<br>    <span class="hljs-built_in">COMMAND</span>(help),<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>  这里分别使用宏<strong>字符串化</strong>和宏<strong>连接</strong>。</p><h2 id="可变参数宏-Variadic-Macros">可变参数宏[Variadic Macros]</h2><p>  和函数一样，宏也可以在声明时接受一个可变数量的参数，语法也与函数定义相似。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> eprintf(...) fprintf(stderr, __VA_ARGS__)</span><br></code></pre></td></tr></table></figure><p>  这样的宏被称为<strong>可变参数宏</strong>。当可变参数宏被调用时，<u>所有在最后一个命名参数之后传递给宏的参数（在这个例子中，宏没有命名参数）都被视为可变参数部分</u>。这意味着，<u>包括任何逗号在内的所有标记（tokens）都被视为可变参数</u>。</p><p>  在宏体内，<code>__VA_ARGS__</code>是一个特殊的标识符，用来表示传递给宏的所有可变参数。当宏展开时，<code>__VA_ARGS__</code>会被替换为宏调用中传递的所有实际参数。在宏展开过程中，<code>__VA_ARGS__</code>将被替换为宏调用中提供的实际参数序列。这意味着，宏调用中的参数将直接替换宏定义中的<code>__VA_ARGS__</code>，包括所有的逗号和标记。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(...) printf(__VA_ARGS__)</span><br><br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>); <span class="hljs-comment">// 可以看到，逗号也作为可变参数的一部分</span><br></code></pre></td></tr></table></figure><ol><li>可变参数中的宏<br>  在可变参数被插入到宏展开中之前，它们会像普通参数一样被完全宏展开。也就是说，如果可变参数中包含宏，这些宏会在被传递到可变参数之前被展开。如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(...) printf(__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FMT <span class="hljs-string">&quot;Hello, %s!\n&quot;</span></span><br><br><span class="hljs-built_in">LOG</span>(FMT, <span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>字符串化可变参数（#）<br>  同样可以使用 <code>#</code> 操作符来字符串化可变参数，这样可以将可变参数转化为字符串字面量。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGIFY(...) #__VA_ARGS__</span><br><br><span class="hljs-built_in">STRINGIFY</span>(some text)<br><br><span class="hljs-comment">// 预处理展开后：</span><br><span class="hljs-string">&quot;some text&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用 <code>##</code> 操作符<br>  实际上，使用 <code>##</code> 操作符将可变参数的首位标记与其他标记连接在一起也是允许的，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIX</span>(MY_, function)<br><br><span class="hljs-comment">// 预处理展开后：</span><br>MY_function<br></code></pre></td></tr></table></figure><p>  需要注意的是，当使用 <code>##</code> 连接可变参数时，如果可变参数本身为空，那么对应连接的空白标记的情况，这个时候 <code>##</code> 操作符不会有任何效果。</p><p><br><br><br><br></p><p>  如果宏很复杂，那么可能希望变量参数有一个比<code>__VA_ARGS__</code>更具描述性的名称。<code>CPP</code>允许这样，作为一种扩展。可以立即在<code>...</code>前面写入一个参数名称；该名称用于变量参数。可以编写上面的<code>eprintf</code>宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> eprintf(args...) fprintf(stderr, args)</span><br></code></pre></td></tr></table></figure><p>需要注意的是，使用了拓展名之后，不能在同一个宏中同时使用拓展名和 <code>__VA_ARGS__</code>。</p><p>  就如前面的例子，在一个可变参数宏中既可以存在命名参数和可变参数，如上面的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br></code></pre></td></tr></table></figure><p>但这实际上存在一个可能的问题——当此时可变参数为空时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIXZ</span>(MY_, )<br></code></pre></td></tr></table></figure><p>在 <code>C++20</code> 以前，<code>PASTE_PREFIXZ(MY_, )</code> 中的 <code>,</code> 被视为可变参数的一部分，所以最终展开的结果是 <code>MY_,</code>，这与我们的预期不符。这个问题在 <code>C++20</code> 后已经被解决了——实际上我们已经可以完全忽略可变参数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASTE_PREFIX(prefix, ...) prefix ## __VA_ARGS__</span><br><br><span class="hljs-built_in">PASTE_PREFIXZ</span>(MY_) <span class="hljs-comment">// 这里逗号都可以不要</span><br></code></pre></td></tr></table></figure><p>  其次，<code>C++20</code>引入了<code>__VA_OPT__</code>函数宏。此宏可能<u>只出现在可变参数宏的定义中</u>。它提供了一种条件展开机制，允许开发者根据可变参数是否存在来决定是否展开某些代码。其工作原理：</p><ol><li><p>条件展开</p><ul><li><code>__VA_OPT__</code>宏函数检查可变参数（<code>variable argument</code>）是否有任何标记（<code>tokens</code>）；</li><li>如果可变参数中包含至少一个标记，那么<code>__VA_OPT__</code>会将其参数展开为这些标记；</li><li>如果可变参数中不包含任何标记（即为空），那么<code>__VA_OPT__</code>展开为空，不会产生任何代码。</li></ul></li><li><p>语法</p><ul><li><code>__VA_OPT__</code>的使用语法是<code>__VA_OPT__(参数)</code>，其中参数是当可变参数非空时应该展开的代码；</li><li>常用：<code>__VA_OPT__(op1, op2)</code>：其中 <code>op1</code> 对应可变参数中不包含任何标记时的操作，<code>op2</code> 对应可变参数中包含标记时的操作。<code>op1</code> 通常为空，使得当可变参数中不包含任何标记时展开为空。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(msg, ...) printf(<span class="hljs-string">&quot;Log: &quot;</span> msg <span class="hljs-string">&quot;\n&quot;</span> __VA_OPT__(, ##__VA_ARGS__) )</span><br><br><span class="hljs-comment">// 调用示例</span><br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;This is a message&quot;</span>);<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;This is a message&quot;</span>, <span class="hljs-string">&quot; with additional info&quot;</span>);<br><br><span class="hljs-comment">// 预处理之后：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Log: This is a message\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Log: This is a message, with additional info\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>LOG</code>宏定义了一个可变参数宏，其中使用了<code>__VA_OPT__</code>；</li><li>当只有<code>msg</code>参数被提供时，<code>__VA_ARGS__</code>为空，<code>__VA_OPT__(, ##__VA_ARGS__)</code>展开为空，因此没有额外的代码被添加；</li><li>当提供了额外的参数时，<code>__VA_ARGS__</code>非空，<code>__VA_OPT__(, ##__VA_ARGS__)</code>展开为, <code>##__VA_ARGS__</code>，这允许<code>printf</code>函数接受额外的参数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
      <category>Macros</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>C</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（二）</title>
    <link href="/2024/11/20/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_2/"/>
    <url>/2024/11/20/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、宏参数">一、宏参数</h2><p>  和真正的函数一样，类函数宏也<strong>可以接受参数</strong>。类函数宏需要参数时，你需要将参数插入圆括号<code>()</code>中，这和调用函数时一样(函数声明和定义时需要指明参数类型，宏是文本替换，所以不需要提供参数类型信息)。需要注意的是，宏参数须为有效的 <code>C/C++</code> 标识符，并且在<strong>存在多个参数时使用逗号隔开，以及可选的空格</strong>。</p><h3 id="1-1-调用宏的方式">1.1 调用宏的方式</h3><p>  当想要使用一个带有参数的宏时，宏名称后接一对圆括号<code>()</code>，并且<strong>在括号内插入实际的参数列表，参数列表用逗号隔开</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b)? (a): (b))</span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="1-2-宏调用可以跨多行">1.2 宏调用可以跨多行</h3><p>  宏的调用不必限制在源文件的单行内，它<strong>可以跨越多行</strong>。这意味着你可以在调用宏时，在参数列表中使用换行符，以提高代码的可读性。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<br>    a + b,<br>    c + d<br>);<br></code></pre></td></tr></table></figure><p>因为上一节讲过，所有宏都会被展开成源代码中的一行。</p><h3 id="1-3-参数数量必须匹配">1.3 参数数量必须匹配</h3><p>  当然，在调用宏时<strong>提供的参数数量必须与宏定义中的参数数量相匹配</strong>。如果宏定义了两个参数，调用时也必须提供两个参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><h3 id="1-4-宏展开时参数的替换">1.4 宏展开时参数的替换</h3><p>  当宏被展开时，<strong>宏体</strong>中的每个参数都会被对应的实际参数替换。这里的<strong>替换</strong>指的是<u>将宏定义中的参数名称替换为实际参数的代码</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b)? (a): (b))</span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><h3 id="1-5-参数的使用是可选的">1.5 参数的使用是可选的</h3><p>  <strong>宏中定义的参数的使用是可选的</strong>，宏体定义的参数不一定要在宏体中使用。可以定义一个参数，但在宏体中不使用它，或者只使用部分参数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_LOG(x, y) printf(<span class="hljs-string">&quot;Value of x: %d\n&quot;</span>, x)</span><br></code></pre></td></tr></table></figure><h3 id="1-6-宏调用时参数的处理规则">1.6 宏调用时参数的处理规则</h3><h4 id="1-参数前后的空白字符被丢弃">1. 参数前后的空白字符被丢弃</h4><p>  在宏调用中，每个参数前后的空白字符（空格、制表符等）都会被丢弃。这意味着，无论实际参数前后有多少空白字符，它们都不会出现在宏展开后的代码中。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(    <span class="hljs-number">2</span>    ,    <span class="hljs-number">3</span>    );<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>可以看到，参数 <code>2</code> 和<code>3</code>前后的空白字符都被丢弃。</p><h4 id="2-参数内部的空白字符被压缩为单个空格">2. 参数内部的空白字符被压缩为单个空格</h4><p>  在参数内部，所有的空白字符（包括空格、制表符等）都会被压缩为单个空格。这意味着，无论参数内部有多少连续的空白字符，它们都会被替换为一个空格。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span> +    <span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = ((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span> + <span class="hljs-number">4</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span> + <span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure><p>参数<code>3 +    4</code>中的多个空白字符被压缩成了一个空格。</p><h4 id="3-参数内的括号必须平衡">3. 参数内的括号必须平衡</h4><p>  在参数内部，如果使用了圆括号，那么这些圆括号必须平衡（即每对开括号(必须有对应的闭括号)）。<u>在平衡的圆括号内部的逗号不会导致参数的结束，简单理解就是圆括号中的逗号不会将其分隔成不同参数</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = (((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) &gt; (<span class="hljs-number">3</span>)? ((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>且不论上述宏展开后的代码是否合法（实际上宏展开也不会进行语法检查），参数<code>(2, 3)</code>并没有被分隔成两个参数 <code>(2</code> 和 <code>3)</code>。所以说，圆括号务必要平衡。</p><h4 id="4-方括号和花括号不需要平衡">4. 方括号和花括号不需要平衡</h4><p>  对于方括号<code>[]</code>和花括号<code>&#123;&#125;</code>，不需要平衡，其内部的逗号仍然会被视为参数分隔符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">3</span>); <span class="hljs-comment">// 三个参数 [2、3] 和 3</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-number">3</span>); <span class="hljs-comment">// 三个参数 &#123;2、3&#125; 和 3</span><br></code></pre></td></tr></table></figure><p>这里<strong>实际上是无法进行宏展开的</strong>，会导致编译错误，因为宏定义时只接受两个参数，而这里提供了三个参数。</p><h3 id="1-7-宏参数的展开规则">1.7 宏参数的展开规则</h3><ol><li><p>宏参数的完全展开<br>  <u>在宏体中替换参数之前，所有传递给宏的实际参数都会先进行完全的宏展开</u>。这意味着，如果实际参数本身是一个宏，或者包含宏，那么这些宏会首先被展开。</p></li><li><p>替换后的再次扫描<br>  替换参数到宏体之后，整个宏体（包括替换后的参数）会再次被扫描，以查找是否有更多的宏需要展开。这个过程会持续进行，直到没有更多的宏可以展开。</p></li></ol><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(<span class="hljs-built_in">MAX</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>第一次，参数进行展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>), <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>第二次，替换后的再次扫描：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = ((((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>))) &gt; (<span class="hljs-number">3</span>)? (((<span class="hljs-number">2</span>) &gt; (<span class="hljs-number">3</span>)? (<span class="hljs-number">2</span>): (<span class="hljs-number">3</span>))): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>事实上，你甚至在为宏传递空参数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实际调用</span><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">MAX</span>(, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 预处理展开后</span><br><span class="hljs-type">int</span> n = (() &gt; (<span class="hljs-number">3</span>)? (): (<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>但是在传空参数时仍然要确保参数的匹配。</p><p>  需要注意的是：出现在<strong>字符串中的宏参数不会被它们相应的实际参数替换</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo(x) x, <span class="hljs-string">&quot;x&quot;</span></span><br><br><span class="hljs-comment">// 实际调用</span><br><span class="hljs-built_in">foo</span>(bar)<br><br><span class="hljs-comment">// 预处理展开后</span><br>bar, <span class="hljs-string">&quot;x&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>到这里，你一定会疑惑，为什么我们在宏定义时，宏体中的参数都会包裹在一对圆括号内</p></blockquote><h3 id="1-8-宏体参数用圆括号包裹的原因">1.8 宏体参数用圆括号包裹的原因</h3><h4 id="1-操作符优先级：">1. 操作符优先级：</h4><p>  在C/C++中，宏参数可能会与宏体中的其他代码一起参与运算。如果不使用括号，可能会因为操作符优先级的问题导致宏的展开结果与预期不符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) x * x</span><br></code></pre></td></tr></table></figure><p>  如果你使用<code>SQUARE(a + b)</code>，宏会展开为<code>a + b * a + b</code>，这显然不是我们想要的结果，因为按照乘法优先于加法的规则，它实际上变成了<code>a + (b * a) + b</code>。正确的结果应该是<code>(a + b) * (a + b)</code>。</p><h4 id="2-使用括号可以确保参数作为一个整体被处理：">2. 使用括号可以确保参数作为一个整体被处理：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) (x) * (x)</span><br></code></pre></td></tr></table></figure><p>  这样，<code>SQUARE(a + b)</code>会正确展开为<code>(a + b) * (a + b)</code>。</p><h4 id="3-避免宏参数为空：">3. 避免宏参数为空：</h4><p>  如果宏的参数可能为空（例如，在宏定义中使用<code>##</code>运算符进行连接时），不使用括号可能会导致编译错误。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EMPTY()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GLUE(x, y) x ## y</span><br><br><span class="hljs-built_in">GLUE</span>(EMPTY, <span class="hljs-type">int</span>) var; <span class="hljs-comment">// 这将尝试定义一个名为&quot;int&quot;的变量，而不是&quot;Emptyint&quot;</span><br></code></pre></td></tr></table></figure><p>  如果<code>EMPTY</code>宏没有括号，<code>GLUE(EMPTY, int)</code>将尝试将<code>EMPTY</code>和<code>int</code>连接起来，而不是将<code>EMPTY()</code>作为一个整体与<code>int</code>连接。</p><h4 id="4-参数可能包含多个标记：">4. 参数可能包含多个标记：</h4><p>  如果宏参数本身是一个复合表达式或多个标记，那么使用括号可以确保整个表达式被正确处理。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE_AND_INCREMENT(x) ((x) * (x)) + 1</span><br></code></pre></td></tr></table></figure><p>  这里，<code>(x)</code>确保了<code>x</code>的整个表达式被乘以自身，然后再加<code>1</code>。</p><h4 id="5-提高代码的可读性和一致性：">5. 提高代码的可读性和一致性：</h4><p>  使用括号可以使宏的定义更加清晰，让阅读代码的人更容易理解宏的意图和行为。</p><h2 id="二、字符串化">二、字符串化</h2><p>  预处理器中的字符串化（<code>Stringizing</code>）操作。这是一种将宏参数转换为字符串常量的技术。有时可能希望将宏参数转换为字符串常量。<u>在字符串常量中，参数不会被替换，但是可以使用<code>#</code>预处理操作符来实现这一点</u>。</p><h3 id="2-1-操作符的使用">2.1 #操作符的使用</h3><p>  当宏参数前面有一个<code>#</code>操作符时，预处理器会用实际参数的文本内容替换它，并将其转换为字符串常量。这与普通的参数替换不同，因为参数不会首先被宏展开。</p><p>  字符串化操作<u>不会在参数替换之前对参数进行宏展开</u>。这意味着如果参数是一个宏，它不会被展开，而是直接将其名称作为字符串插入。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING hello</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(STRING)<br></code></pre></td></tr></table></figure><p>预处理展开之后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;STRING&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，宏<code>STRINGFY</code>的参数也是一个宏<code>STRING</code>，但并没有被展开为 <code>hello</code>，而是直接将其名称字符串化为了字符串常量<code>&quot;STRING&quot;</code>。</p><p>  不能直接将参数与周围的文本组合在一起并一次性字符串化。相反，你可以编写一系列相邻的字符串常量和字符串化的参数。预处理器会将字符串化的参数替换为字符串常量，然后，编译器会将所有相邻的字符串常量合并为一个长字符串。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WARN_IF(EXP) \</span><br><span class="hljs-meta">do &#123; <span class="hljs-keyword">if</span> (EXP) \</span><br><span class="hljs-meta">        fprintf (stderr, <span class="hljs-string">&quot;Warning: &quot;</span> #EXP <span class="hljs-string">&quot;\n&quot;</span>); &#125; \</span><br><span class="hljs-meta">while (0)</span><br><span class="hljs-built_in">WARN_IF</span> (x == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>预处理器展开后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> &#123; <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) \<br>    <span class="hljs-built_in">fprintf</span> (stderr, <span class="hljs-string">&quot;Warning: &quot;</span> <span class="hljs-string">&quot;x == 0&quot;</span> <span class="hljs-string">&quot;\n&quot;</span>); \<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>注意，这里的<code>\</code>表示行间是连接的，因为宏展开会成一行，这里为了方便，增加了换行。可以看到，<code>EXP</code> 的参数被替换为 <code>if</code> 语句中的条件参数和 <code>fprintf</code> 参数中的 <code>string</code> 参数。<u>如果 <code>x</code> 是一个宏，它将在 <code>If</code> 语句中展开，但不会在字符串中展开</u>。后面的几个字符串常量<code>&quot;Warning: &quot; &quot;x == 0&quot; &quot;\n&quot;</code>会在编译器的帮助下合并成一个字符串常量。</p><blockquote><p>这里其实还提到了 <code>do...while(0)</code> 循环的使用，这是一种技巧，将在后续章节探讨。</p></blockquote><p>  可见，字符串化不仅仅是在宏参数周围添加双引号那么简单。预处理器会进行额外的处理，以确保生成的字符串常量是有效的，并且包含正确的内容。</p><h3 id="2-2-宏参数字符串化的细节处理">2.2 宏参数字符串化的细节处理</h3><h4 id="1-预处理器对引号和反斜杠的处理">1. 预处理器对引号和反斜杠的处理</h4><p>  当宏参数中包含字符串常量时，预处理器会对其进行转义处理。这意味着，如果宏参数中包含双引号或反斜杠，预处理器会在它们前面添加反斜杠来进行转义。这样做的目的是为了确保生成的字符串常量在<code>C/C++</code>语言中是有效的。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(<span class="hljs-string">&quot;hello\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>预处理器展开后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;\&quot;hello\\n\&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-非字符串或字符常量中的反斜杠不加倍">2. 非字符串或字符常量中的反斜杠不加倍</h4><p>  如果反斜杠不在字符串或字符常量中，它们不会被加倍。例如，<code>\n</code>单独字符串化时，结果就是<code>&quot;\n&quot;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGFY(Argu) #Argu</span><br><br><span class="hljs-built_in">STRINGFY</span>(\n)<br></code></pre></td></tr></table></figure><p>预处理器展开后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;\n&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-字符串化中的空白处理">3. 字符串化中的空白处理</h4><p>  在字符串化过程中，宏参数中的所有前导和尾随空白都会被忽略。文本中的任何空白序列（空格、制表符等）在字符串化结果中会被转换为单个空格。其实也是一种特殊的宏参数处理。</p><h4 id="4-无法将宏参数转换为字符常量">4. 无法将宏参数转换为字符常量</h4><p>  没有办法将宏参数直接转换为字符常量。这是因为字符常量在<code>C/C++</code>语言中是用单引号括起来的单个字符，而字符串化操作是将整个宏参数转换为双引号括起来的字符串常量。</p><h3 id="2-3-如何字符串化宏参数的展开">2.3 如何字符串化宏参数的展开</h3><p>  如果要将<strong>宏参数展开后的结果转换成字符串常量</strong>，则需要使用<strong>两级宏</strong>（即<strong>嵌套宏</strong>）来实现。这是因为在预处理阶段，<u>宏参数首先被展开，然后才进行字符串化</u>。如果直接在宏中使用<code>#</code>操作符来字符串化宏参数，那么字符串化的是宏参数本身，而不是它展开后的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xstr(s) str(s)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> str(s) #s</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo 4</span><br><br><span class="hljs-built_in">xstr</span> (foo)<br></code></pre></td></tr></table></figure><p>第一次展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">xstr</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// 第一次展开并非字符串化，故参数会展开</span><br></code></pre></td></tr></table></figure><p>第二次展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">str</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// 第二次展开是 xstr 展开</span><br></code></pre></td></tr></table></figure><p>然后字符串化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;4&quot;</span> <span class="hljs-comment">// 最后是字符串化</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
      <category>Macros</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>C</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索C/C++宏的艺术（一）</title>
    <link href="/2024/11/18/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_1/"/>
    <url>/2024/11/18/Macros/%E5%AE%8F%E7%9A%84%E8%89%BA%E6%9C%AF_1/</url>
    
    <content type="html"><![CDATA[<h3 id="宏是什么？">宏是什么？</h3><p>  <strong>宏</strong>(<code>Macros</code>)是一段代码片段，每个<strong>宏</strong>被赋予了一个名称。<strong>无论何时使用该名称，都将由宏的内容替换</strong>（其实就是文本替换）。宏有两种——<strong>类对象宏(<code>Object-like Macros</code>)<strong>和</strong>类函数宏(<code>Function-like Macros</code>)</strong>。它们的差异主要体现在使用时，使用<strong>类对象宏</strong>时类似于数据对象，使用<strong>类函数宏</strong>时类似于函数调用。</p><p>$$<br>宏<br>\begin{cases}<br>类对象宏 \\<br>类函数宏<br>\end{cases}$$</p><h3 id="类对象宏-Object-like-Macros">类对象宏(Object-like Macros)</h3><p>  <strong>类对象宏</strong>其实就是一个简单的<strong>标识符</strong>，其在代码中被使用之处会被其所指的代码片段给替换。之所以将其称为<strong>类对象宏</strong>，是因为在代码中使用<strong>类对象宏</strong>时就像在使用普通的数据对象一样。通常的<u>使用场景是给数值常量赋予符号名称</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 示例1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14</span><br></code></pre></td></tr></table></figure><p>  <u>在<code>C/C++</code>中，宏是通过预处理指令<code>#define</code>来创建的</u>。这个指令告诉预处理器定义一个新的宏（预处理器是C/C++编译过程中的一个阶段，负责处理源代码中的预处理指令，如宏定义、文件包含和条件编译等）。</p><p>  <code>#define</code>后面紧跟的是宏的<strong>名称</strong>。宏的名称<strong>通常以大写字母表示</strong>，以区分于变量和其他标识符，这是一种约定俗成的命名习惯，有助于提高代码的可读性。</p><p>  宏名称之后是宏的<strong>替换列表(replacement list)</strong>，也就是<u>当宏被使用时，预处理器将宏名称替换为这个列表中的代码</u>。这个替换列表有时被称为宏的“<strong>体</strong>”(<code>body</code>)、“<strong>展开</strong>”(<code>expansion</code>)。</p><blockquote><p>需要注意得是，宏定义后没有分号！本质上宏是一种预编译指令，并不是<code>C/C++</code>得一条语句，所以没有分号。</p></blockquote><p>  示例1中定义了一个名为 <code>PI</code> 的宏表示圆周率，其对应的<strong>宏体</strong>为我们希望圆周率所取得的数值 <code>3.14</code>。如果在 <code>define</code> 语句之后，某个代码位置使用了这个宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> perimeter = <span class="hljs-number">2</span>*PI;<br></code></pre></td></tr></table></figure><p>然后 <code>C/C++</code> 预处理器将识别并展开宏 <code>PI</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> perimeter = <span class="hljs-number">2</span>*<span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>  通常，<u>宏的主体结束于 <code>#define</code> 行的末尾</u>。如果需要，可以使用<strong>反斜杠</strong><code>\</code><strong>换行</strong>将定义继续到多行。然而，<u>当宏被展开时，它们都会出现在一行中</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBERS 1, \</span><br><span class="hljs-meta">                2, \</span><br><span class="hljs-meta">                3</span><br><br><span class="hljs-type">int</span> nums[] = &#123;NUMBERS&#125;;<br><br><span class="hljs-comment">// 预处理展开后：</span><br><br><span class="hljs-type">int</span> nums[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里官方文档说：因为预处理后宏会变成一行，那么报错信息提供的行号和我们实际所看到的行号就存在偏差。可能因为时间原因，这个问题已经不存在了：</p><p><img src="/img/in_posts/Macros/code1.png" alt="错误代码"><br>这段代码里，<code>return</code> 语句后没写分号。查看报错信息：<br><img src="/img/in_posts/Macros/code1_err_info.png" alt="报错信息"><br>可以看到，报错信息里面行号是正常显示的，这个问题可以忽略。</p></blockquote><p>  在<code>C/C++</code>语言中定义宏时，宏体可以包含任何内容，只要这些内容能够分解成有效的<strong>预处理标记</strong>（<code>preprocessing tokens</code>）。这里的“预处理标记”指的是<u>预处理器能够识别的基本单位，比如关键字、标识符、字面量、运算符等</u>。</p><blockquote><p>什么意思？如下：<br><strong>无限制的内容</strong><br>宏体中可以放入任何字符序列，<u>预处理器不会对宏体的内容做语法检查，它只负责将宏名替换为宏体的内容</u>；<br>正因如此，宏体中的代码片段甚至不必看起来是 <code>C/C++</code> 的代码，但是编译结束可能会投来编译错误.😂</p></blockquote><p>  <code>C/C++</code> 预处理器<strong>按顺序扫描程序</strong>。宏定义在编写它们的地方生效，<u>也即是说在其定义之处之后的作用域内有效</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = N;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 3</span><br><span class="hljs-type">int</span> b = N;<br></code></pre></td></tr></table></figure><p>预处理之后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = N;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>这里就出错了，预处理器按顺序扫描到第一个语句时，<code>N</code> 并没有被定义，而在其后方才被定义为宏，于是只有<code>b</code>的赋值语句中 <code>N</code> 被正确展开成了 <code>3</code>。</p><p>  <code>C/C++</code>预处理器在处理宏时的展开过程。<u>当宏体中出现宏的调用（即宏名的使用）时，预处理器会将展开后的宏体中的宏继续展开</u>。这个过程是<strong>递归</strong>的，直到所有的宏都被替换为它们的值或者代码片段。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE BUFFERSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span><br></code></pre></td></tr></table></figure><p>那么实际上，<code>TABLESIZE</code> 首先被展开成 <code>BUFSIZE</code>，然后 <code>BUFSIZE</code> 又被展开为 <code>4</code>，所以最终的效果是使用 <code>TABLESIZE</code> 的地方都被展开成了 <code>4</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">TABLESIZE <br>    -&gt; BUFSIZE<br>    -&gt; <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>  注意，在定义 <code>TABLESIZE</code> 时没有定义 <code>BUFSIZE</code>。<code>TABLESIZE</code> 的<code>#define</code>完全使用指定的展开式，因为不会进行语法检查，并且不检查它是否也包含宏名称。只有当您使用 <code>TABLESIZE</code> 时，才会扫描其展开的结果以查找更多的宏名称，因为使用 <code>TABLESIZE</code> 之处也处于 <code>BUFSIZE</code> 作用域之内。这也说明了，宏指令的位置与最终展开的结果相关，预处理最终将会使用当前生效的宏进行展开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLESIZE BUFSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> BUFSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 37</span><br></code></pre></td></tr></table></figure><p>这个示例中，<code>TABLESIZE</code> 最终被展开为了 <code>37</code>。</p><p>  还有一种情况：如果宏体中包含自身的宏名称(直接或通过中间宏) ，<u>则在检查更多宏时不再展开。这可以防止无限递归</u>。下面是一个例子来说明这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO FOO</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FOO</code> 宏被定义为它自己。当预处理器遇到 <code>FOO</code> 时，它会尝试展开 <code>FOO</code>，但发现 <code>FOO</code> 的定义就是它自己，所以预处理器不会再次展开 <code>FOO</code>，避免了无限递归。</p><p>另一个更复杂的例子，涉及中间宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BAR FOO</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO BAR</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>FOO</code> 被定义为 <code>BAR</code>，而 <code>BAR</code> 被定义为 <code>FOO</code>。如果预处理器尝试展开 <code>FOO</code>，它会被替换为 <code>BAR</code>，然后 <code>BAR</code> 又会尝试展开为 <code>FOO</code>，但此时预处理器已经知道 <code>FOO</code> 会展开为 <code>BAR</code>，所以它不会再次展开 <code>FOO</code>，避免了无限递归。</p><p>在这两种情况下，预处理器都会停止进一步展开宏，以防止无限递归的发生。这种自我引用的宏定义通常不是有意为之的，因为它们不会产生有用的结果，但它们确实展示了预处理器如何处理宏的递归展开，这部分将在后续 <code>自引用宏章节</code> 介绍。</p><h3 id="类函数宏-Function-like-Macros">类函数宏(Function-like Macros)</h3><p>  实际上，还可以定义<strong>看起来像函数调用的宏</strong>。这些被称为<strong>类函数宏</strong>。要定义一个类似函数的宏，同样使用 <code>#define</code>指令，但在<u>宏名称后紧接一对括号</u>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lang_init()  c_init()</span><br><br><span class="hljs-comment">// 预处理后</span><br><span class="hljs-built_in">lang_init</span>()<br>     -&gt; <span class="hljs-built_in">c_init</span>()<br></code></pre></td></tr></table></figure><p>当定义了一个类函数宏时，只有当这个宏的名字后面紧跟着一对括号时，它才会被展开。<u>如果宏的名字后面没有括号，那么它就不会被展开，而是保持原样</u>。这在存在同名的<strong>函数</strong>和<strong>类函数宏</strong>时，希望调用真实函数而不是宏时进行区分很有用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo() <span class="hljs-comment">/* optimized inline version */</span></span><br>...<br><span class="hljs-built_in">foo</span>();<br>funcptr = foo;<br></code></pre></td></tr></table></figure><p>这里对 <code>foo()</code> 的调用将使用<strong>宏</strong>，而函数指针 <code>funcptr</code> 获取的是<strong>函数</strong><code>foo</code> 的地址。但是这里如果将 <code>foo()</code> 进行展开将会出现语法错误……</p><p>  如果在宏定义中的宏名称和括号之间放置空格，则不是类函数宏，而是定义了一个类对象宏，其扩展恰好以一对括号开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lang_init ()  c_init()</span><br><br><span class="hljs-comment">// 预处理后</span><br><span class="hljs-built_in">lang_init</span>()<br>     -&gt; ()  <span class="hljs-built_in">c_init</span>()()<br></code></pre></td></tr></table></figure><p>需要注意。</p><!-- [官方文档](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) -->]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
      <category>Macros</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>C</tag>
      
      <tag>Macros</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试博客功能</title>
    <link href="/2024/11/16/Test/test/"/>
    <url>/2024/11/16/Test/test/</url>
    
    <content type="html"><![CDATA[<h1>线性代数——二次型</h1><h2 id="一、二次型的定义及其矩阵表达式">一、二次型的定义及其矩阵表达式</h2><p>  $n$ 元变量 $x_1$，$x_2$，…，$x_n$ 的二次齐次多项式</p><p>$$f(x_1, x_2, …, x_n) = a_{11}x_1^2+2a_{12}x_1x_2+…+2a_{1n}x_1x_n\\+a_{22}x_2^2+2a_{23}x_2x_3+…+2a_{2n}x_2x_n\\+…+a_{nm}x_n^2$$</p><p>称为 $n$ <strong>元二次型</strong>，简称<strong>二次型</strong>.</p><p>  这里只介绍系数 $a_{ij} \in R(i \le j; i,j = 1, 2, …, n)$的情况，称此二次型 $f$ 为<strong>实二次型</strong>.</p><p>  因为 $x_ix_j = x_jx_i$，于是令 $a_{ij} = a_{ji}(i,j = 1, 2, …, n)$，则 $2a_{ij}x_ix_j = a_{ij}x_ix_j+a_{ji}x_jx_i$，于是令</p><p>$$<br>A = \begin{pmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}<br>\end{pmatrix}$$</p><p>$$x = \begin{pmatrix}<br>x_{1} \\<br>x_{2} \\<br>\vdots \\<br>x_{n} \\<br>\end{pmatrix}$$</p><p>则二次型可以表示为</p><p>$$f(x) = x^TAx$$</p><p>其中，<strong>实对称矩阵</strong>$A$称为<strong>二次型</strong>$f(x)$<strong>的矩阵</strong>. 这里 $A$ 是一个对称矩阵，$A_{ij} = (a_{ij}), a_{ij} = a_{ji}$，即满足 $A^T = A$. 实际上二次型可以有多种写法，如：<br>$$f(x) = x_1^2+x_2^2+4x_1x_2$$<br>或<br>$$f(x) = x_1^2+x_2^2+1x_1x_2+3x_2x_1$$</p><p>于是对应的矩阵 $A$ 分别为：<br>$$<br>A = \begin{pmatrix}<br>1 &amp; 2  \\<br>2 &amp; 1 \\<br>\end{pmatrix}$$</p><p>和</p><p>$$<br>A = \begin{pmatrix}<br>1 &amp; 1  \\<br>3 &amp; 1 \\<br>\end{pmatrix}$$</p><p>而这里作了规定，<strong>二次型的矩阵必须为对称矩阵</strong>，那么如此代表二次型的矩阵就是<strong>唯一</strong>的了.</p><h2 id="二、合同变换，二次型的合同标准型、规范型">二、合同变换，二次型的合同标准型、规范型</h2><h3 id="1-线性变换的定义">1.线性变换的定义</h3><p>  对于 $n$元二次型 $f(x_1, x_2, …, x_n)$，若令</p><p>$$ \left{<br>\begin{aligned}<br>x_1 &amp;= c_{11}y_1 + c_{12}y_2 + \cdots + c_{1n}y_n \<br>x_2 &amp;= c_{21}y_1 + c_{22}y_2 + \cdots + c_{2n}y_n \<br>&amp;\vdots \<br>x_n &amp;= c_{n1}y_1 + c_{n2}y_2 + \cdots + c_{nn}y_n<br>\end{aligned}<br>\right.<br>$$</p><p>记<br>$$x = \begin{pmatrix}<br>x_{1} \\<br>x_{2} \\<br>\vdots \\<br>x_{n} \\<br>\end{pmatrix}$$</p><p>$$<br>C = \begin{pmatrix}<br>c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n} \\<br>c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>c_{n1} &amp; c_{n2} &amp; \cdots &amp; c_{nn}<br>\end{pmatrix}$$</p><p>$$y = \begin{pmatrix}<br>y_{1} \\<br>y_{2} \\<br>\vdots \\<br>y_{n} \\<br>\end{pmatrix}$$</p><p>则，上式可以写为：</p><p>$$x = Cy$$<br>上述变换称为<strong>线性变换</strong>，若线性变换的系数矩阵$C$可逆，即 $|C| \ne 0$，则称为<strong>可逆线性变换</strong>. 现给出：<br>$$f(x) = x^TAx$$<br>令 $x = Cy$，则<br>$$f(x) = (Cy)^TA(Cy) = y^T(C^TAC)y$$<br>记 $B = C^TAC$，则<br>$$f(x) = y^TBy = g(y)$$<br>显然，这又是一个新的二次型：即二次型 $f(x)=x^TAx$通过线性变换 $x=Cy$ 得到了一个新的二次型 $g(y) = y^TBy$</p><figure class="highlight c++"><figcaption><span>&#123;#测试代码块功能&#125; &#123;:linenos&#125; &#123;:highlight</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试链接其他帖子<br><a href="https://hijackiee.github.io/2024/12/26/Concurrency/c++%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B1%82%E6%AC%A1%E9%94%81/">层次锁</a></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
      <tag>latex</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
